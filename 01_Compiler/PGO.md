# PGO

LLVM的**Profile-Guided Optimization (PGO)**是一种编译优化技术，通过使用运行时收集的性能数据来指导编译器优化程序。PGO可以显著提高程序的性能，尤其是那些有复杂控制流或需要频繁执行的关键路径的程序。

## 工作原理
1. **编译并插桩**：首先，编译器在编译程序时插入额外的代码以收集运行时数据。这个插桩后的程序称为**插桩二进制（instrumented binary）**。
2. **收集数据**：运行插桩二进制，收集程序在实际使用中的运行时数据。这些数据通常包括函数调用频率、分支命中率等。
3. **生成配置文件**：将收集到的运行时数据转换成配置文件（profile data），通常以`.profraw`或`.profdata`文件格式存储。
4. **基于配置文件优化**：使用生成的配置文件重新编译程序，编译器根据这些数据做出更智能的优化决策，如内联函数、重新排序基本块、优化循环等。

## 优点
- **提高性能**：通过识别和优化热点代码路径，显著提高程序的运行速度。
- **更智能的优化决策**：编译器可以基于实际使用模式进行优化，而不仅仅是静态分析。
- **减少代码膨胀**：相较于静态编译时的保守优化，PGO可以避免不必要的内联和代码复制，从而减少最终二进制文件的大小。

## 缺点

某些场景会性能下降

## 使用步骤

### 采样型流水线

```bash
# 1. Build the code with source line table information
> clang++ -O2 -gline-tables-only code.cc -o code
#2. Run the executable under a sampling profiler
> perf record -b ./code
#3. Convert the collected profile data to LLVM format
> create_llvm_prof --binary=./code --out=code.prof
#4. Build the code again using collected profile
> clang++ -O2 -gline-tables-only \
-fprofile-sample-use=code.prof code.cc -o code
```

##### 采样型PGO的优点

- **低开销**：相比插桩PGO，采样型PGO不会在运行时增加额外的插桩代码，性能开销更低。
- **适用于生产环境**：可以在生产环境中运行应用程序来收集性能数据，从而得到更真实的性能分析结果。
- **更精准的优化**：利用实际运行数据，编译器可以进行更精准的优化，提高程序的性能。

##### 适用场景

采样型PGO特别适用于以下场景：

- **性能关键的生产环境**：在生产环境中运行采样分析，收集真实的性能数据，进行精准优化。
- **大规模应用程序**：大型复杂应用的性能瓶颈可能难以通过插桩分析发现，采样型PGO可以更有效地识别这些瓶颈。
- **长期运行的服务**：服务程序在长期运行中可能会经历各种不同的负载，采样型PGO可以捕捉这些不同负载下的性能特征，进行优化。

### 插桩型流水线

```sh
clang -fprofile-instr-generate -o my_program my_program.c	// 插桩编译
./my_program	// 运行插桩二进制
llvm-profdata merge -output=merged.profdata default.profraw	// 生成配置文件
clang -fprofile-instr-use=merged.profdata -o my_program_opt my_program.c	// 基于配置文件编译
```

插桩种类：

• Front-end (FE) `-fprofile-instr-generate` 

• Middle-end (IR) `-fprofile-generate` 

• Middle-end context sensitive (IR CS) `-fcs-profile-generate`

## 适用场景

- **高性能计算**：需要最大化性能的关键应用。
- **复杂控制流程序**：分支和函数调用复杂，传统优化效果不明显的程序。
- **长期运行的服务器应用**：频繁执行的路径经过优化后，可以显著提升整体性能。

## 实际案例

### 疑问？

> ​	针对寄存器分配级别的Profile-Guided Optimization (PGO) 是一种较为高级的优化技术，主要是通过实际运行时收集的性能数据来指导寄存器分配，从而提升程序的执行效率。LLVM在这一方面也有一定的支持和应用，尽管它不像一些更高层次的优化（例如函数内联或分支预测优化）那么普遍。以下是如何在寄存器分配级别上应用PGO的具体方式：
>
> 1. **寄存器使用频率分析**（？）：通过运行时数据收集，了解哪些变量或临时值在执行过程中使用最频繁。根据这些数据，编译器可以更智能地将高频使用的变量分配到寄存器中，而将低频使用的变量分配到内存中。这有助于减少内存访问次数，提高程序执行效率。
>
> 2. **热点路径优化**：在热点路径（即程序中执行最频繁的代码路径）上==优先进行寄存器分配。【可行】==通过PGO数据，编译器能够识别这些热点路径，并确保这些路径上的变量尽可能分配到寄存器中，减少在这些关键路径上的寄存器溢出（register spilling）。
>
> 3. **优化寄存器分配冲突**：利用PGO数据来优化寄存器分配冲突。编译器可以根据实际运行时数据，调整寄存器分配策略，减少寄存器之间的冲突，降低溢出到内存的开销。
>
>    应用于LLVM中，作用主要有：
>
> 1. **指导寄存器分配**：在重新编译程序时，使用分析得到的数据指导寄存器分配。具体包括：
> 2. **高频变量优先分配寄存器**：将使用频率最高的变量分配到寄存器中。
> 3. **减少热点路径的溢出**：在热点路径上优先进行寄存器分配，尽量避免在这些路径上发生寄存器溢出。

### 实践中的应用

虽然寄存器分配级别的PGO在理论上是可行的，但在实际应用中，这种优化技术需要复杂的分析和实现。此外，寄存器分配是一个NP难的问题，即使在没有PGO数据的情况下也已经非常复杂。因此，寄存器分配级别的PGO更适用于对性能有极高要求的应用，或者在某些特定的、高度优化的编译器中实现。

总结来说，LLVM可以在寄存器分配级别上应用PGO，但这需要在代码生成和优化阶段进行复杂的分析和实现，以便充分利用运行时收集的数据来指导寄存器分配，提升程序的执行效率。



热点路径（hot path）是指在程序执行过程中最频繁执行的代码路径。这些路径通常是程序性能优化的重点，因为它们占用了大部分的执行时间。了解热点路径对于性能优化至关重要，而运行时数据是识别这些路径的最可靠途径。然而，在编译时也有一些方法可以推测和预估热点路径，但这些方法通常不如运行时数据准确。以下是关于如何识别和利用热点路径的不同途径：

### 运行时识别热点路径

1. **Profile-Guided Optimization (PGO)**：
   - **插桩和数据收集**：在程序中插入代码，以记录每条指令或基本块的执行频率。用户运行程序，收集这些数据。
   - **分析执行数据**：通过分析收集到的数据，确定程序的热点路径。
   - **指导优化**：使用热点路径信息指导编译器进行优化，如寄存器分配、代码布局优化等。

### 编译时推测热点路径

2. **静态分析和启发式方法**：
   - **基于控制流图（CFG）**：编译器可以通过分析控制流图，推测哪些路径可能是热点路径。例如，循环体内的代码通常执行多次，可能被认为是潜在的热点路径。
   - **基于代码结构**：某些代码结构，如频繁调用的函数、密集的循环等，可能被编译器推测为热点路径。
   - **启发式方法**：编译器可以使用经验规则或启发式方法（heuristics）来推测热点路径。例如，函数调用次数、循环嵌套深度等。

### 静态分析的局限性

尽管编译时推测热点路径的方法可以提供一些指导，但这些方法有明显的局限性：
   - **缺乏运行时信息**：编译器无法准确预测程序在实际运行时的行为，尤其是在输入数据、用户交互等动态因素的影响下。
   - **不够精确**：启发式方法和静态分析只能提供粗略的估计，可能会错过真正的热点路径，或者错误地标记非热点路径为热点。

### 结合静态和动态方法

为了更好地识别和优化热点路径，现代编译器通常结合静态分析和动态数据：
   - **混合方法**：编译器可以先使用静态分析进行初步优化，然后使用运行时数据进行进一步优化。这样可以在开发和测试阶段收集运行时数据，并在生产阶段应用这些优化。
   - **持续优化**：一些编译器和运行时环境支持持续优化（continuous optimization），在程序的整个生命周期内不断收集和应用运行时数据进行优化。

### 总结

热点路径的精确识别主要依赖于运行时数据，因为运行时数据可以准确反映程序在实际运行时的行为。尽管编译时的静态分析和启发式方法可以提供一些指导，但它们通常不如运行时数据精确。因此，Profile-Guided Optimization (PGO) 是识别和优化热点路径的主要手段，通过在运行时收集数据并在编译时利用这些数据来实现性能优化。

# 链接

## 基本概念

**链接**：将多个对象文件或库文件组合成一个可执行文件

**静态链接** (Static Linking)：所有的==库函数都会被复制到最终的可执行文件==中。如果有多个程序使用同一个库，那么==这个库的代码会在每个程序中都有一个副本==。

**动态链接** (Dynamic Linking)：只是在运行时加载所需的库。这样，多个程序可以共享同一个库的单一副本。
~动态链接器是操作系统的一部分，负责在程序运行时加载和链接所需的共享库。运行程序时，动态链接器首先检查这个程序需要哪些共享库，并查找这些库的位置，加载这些库到内存中，并解析程序中的符号引用，确保它们指向正确的地址。~

**动态链接优缺点：**

- **优点**

	①节省内存，多个程序可以共享同一个库的副本。
	②程序更新时，只需更新库文件，而不是每个使用该库的程序。

- 缺点：

	①需要==确保运行环境中有所需的库==
	②可能会出现==版本冲突==，导致程序崩溃
	③加载程序时可能会稍微==慢一些==，因为需要加载库

## 基本流程

经过编译和汇编后的.o文件是ELF relocable(可重定位)的，然后链接成应用程序main的文件格式为ELF executable可执行文件，默认动态链接了**libc**。

<img src="assets/image-20240119132333581.png" alt="image-20240119132333581" style="zoom:25%;" />

- 要求编译出来的**共享库文件的指令代码**是地址无关码$\to$无论加载在哪个内存地址，都能够正常执行。

链接器部分链接生成可执行文件：将目标文件与==所依赖的动态链接库进行链接==。
链接器会查找所需的符号，并==将符号解析为动态链接库函数或变量引用==。生成的可执行文件中会包含动态链接库的依赖信息，如**库名称或符号表索引**。

### **加载时动态链接**

**加载程序**：操作系统首先加载程序的**可执行文件到内存**中。

**解析依赖**：动态链接器**检查==程序的头部==**，**找出程序依赖的所有共享库**（如$\texttt{libc.so中的<stdio.h>}$）。

**加载共享库**：动态链接器**查找这些共享库的位置**，并将它们加载到内存中。

**符号解析**[重点]：**动态链接器解析**程序中的符号引用，**==确保它们指向正确的地址==**。

<img src="assets/image-20240119135716557.png" alt="image-20240119135716557" style="zoom:35%;" />



### 动态链接需要解决什么问题

符号重定位的过程，是**直接对可执行文件进行修改**。但是对于==动态链接==来说，在编译阶段，仅仅是**在可执行文件或者动态库中记录了一些必要的信息**。**重定位过程是在可执行程序、动态库被加载之后，调用可执行程序的入口函数之前**。既然也是重定位，与静态链接过程一样也需要把符号的目标地址填写到代码段中需要重定位的地方。**但对于内存的访问是有权限控制的。**

代码段：可读、可执行。
数据段：可读、可写。

如果进行符号重定位，就需要==对代码进行修改==(填写符号的地址)，但是代码段又没有可写的权限。（$\texttt{main的.data}$不可写）

<img src="assets/image-20240119152244833.png" alt="image-20240119152244833" style="zoom:50%;" />

解决动态链接中的代码重定位问题，==通过增加一层间接性来解决==。既然代码段在被加载到内存中之后不可写，但是**数据段是可写**的。在代码段中引用的外部符号，可以在数据段中增加一个跳板：让代码段先引用数据段中的内容，**然后在重定位时，把外部符号的地址填写到数据段中对应的位置。**

## 位置无关代码

多个进程如何共享程序的一个副本：**可以加载而无需重定位的代码称为位置无关代码**(Position-Independent Code, PIC)。

### 1. PIC数据引用

编译器通过以下事实来生成对全局变量的PIC引用:==无论在内存中的何处加载一个目标模块(包括共享目标模块)，**数据段**与**代码段**的距离总是保持不变==。因此，代码段中任何指令和数据段中任何变量之间的距离都是一个**运行时常量**，与代码段和数据段的绝对内存位置是无关的。  

→在数据段开始的地方创建了一个表，叫做**==全局偏移量表(Global Offset Table, GOT)==**。在GOT中，每个被这个目标模块引用的**全局数据目标**(过程或全局变量)都有一个8字节条目。编译器还**为GOT中每个条目生成一个重定位记录**。==在加载时，动态链接器会重定位GOT中的每个条目，**使得它包含目标的正确的绝对地址**==。每个引用全局目标的目标模块都有自己的GOT。

<img src="assets/image-20240119123448276.png" alt="image-20240119123448276" style="zoom:33%;" />

### GOT实现

>**现代操作系统不允许修改代码段**，只能修改数据段。

如果上面的**代码片段是在一个共享对象**内，==修改了代码段，那么它就无法做到系统内所有进程共享同一个共享对象，因为代码段被修改了==。而动态库的主要一个优点就是<u>多个进程共享同一个共享对象的代码段</u>，节省内存空间，但是进程拥有数据段的独立副本。

在动态链接对应的共享库的 data section 里面保存了一张GOT。虽然共享库的代码部分的物理内存是共享的，但是**数据部分是各个动态链接它的应用程序里面各加载一份**的。所有需要引用当前共享库外部的地址的指令，都会查询 GOT，来找到当前运行程序的虚拟内存里的对应位置。而 GOT 表里的数据，则是在加载共享库的时候写进去的。

<img src="assets/image-20240119123944393.png" alt="image-20240119123944393" style="zoom:33%;" />

- 1.GOT 表位于共享库自己的数据段里。**GOT 表在内存里和对应的代码段位置之间的偏移量**，始终是确定的。==这样共享库就是地址无关的代码==；
- 2.对应的各个程序只需要在物理内存里面加载同一份代码，需要通过各个可执行程序在加载时，生成的各不相同的 GOT 表，来找到它需要调用到的外部变量和函数的地址。

### 2.PIC函数调用

假设程序调用一个由共享库定义的函数。编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。不过，这种方法并不是PIC，因为它需要链接器修改调用模块的代码段，GNU编译系统使用了一种技术来解决这个问题，称为延迟绑定(lazybinding)，将过程地址的绑定推迟到第一次调用该过程时。  

使用延迟绑定的动机是对于一个像libc.so这样的共享库输出的成百上千个函数中，一个典型的应用程序只会使用其中很少的一部分。把函数地址的解析推迟到它实际被调用的地方，能避免动态链接器在加载时进行成百上千个其实并不需要的重定位。第一次调用过程的运行时开销很大，但是其后的每次调用都只会花费条指令和一个间接的内存引用。

延迟绑定通过GOT和PLT（过程链接表）实现，如果一个目标模块调用定义在共享库中的任何函数，那么它就有自己的GOT和PLT。GOT是数据段的一部分，而PLT是代码段的一部分。  

过程链接表(PLT)。PLT是一个数组，其中每个条目是16字节代码。PLT[0]是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。PLT[[](图中未显示)1]调用系统启动函数( libc start main)，它初始化执行环境，调用main函数并处理其返回值。从PLT[2]开始的条目调用用户代码调用的函数。

全局偏移量表(GOT)。GOT也是一个数组，其中每个条目是8字节地址。和PLT联合使用时，GOT[0]和GoT[1]包含动态链接器在解析函数地址时会使用的信息。GOT[2]是动态链接器在ld-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。

got[0]：address of .dynamic section 也就是本ELF动态段(.dynamic段）的装载地址

got[1]：address of link_map object( 编译时填充0）也就是本ELF的link_map数据结构描述符地址，作用：link_map结构，结合.rel.plt段的偏移量，才能真正找到该elf的.rel.plt

got[2]：address of _dl_runtime_resolve function (编译时填充为0) 也就是_dl_runtime_resolve函数的地址，来得到真正的函数地址，回写到对应的got表位置中。

![img](assets/wps11.jpg) 

push：把对应函数的标识符压入栈

重定位：

需要调用一个模块：我现在需要该符号的确定地址。_dl_runtime_resolve()。这个是glibc中的一个函数，作用就是查找动态库中函数的位置并将其写入到程序的GOT表中。

### _dl_runtime_resolve()

告诉_dl_runtime_resolve()需要寻找的符号，也就是函数参数。可以放到栈中或者寄存器传递。

_dl_runtime_resolve()寻找完符号的特定地址后，放到寄存器上，比如%rax，供调用者使用

_dl_runtime_resolve函数的汇编代码就是保存寄存器的值到栈中，然后调用_dl_fixup执行具体的功能，然后从栈中恢复寄存器。_dl_fixup函数传入的两个参数一个是rdi寄存器中存储的link_map，rsi是GOT表中关于PLT重定位的索引值，后面要根据该索引值写入新的地址。

_dl_fixup函数首先通过宏D_PTR从link_map结构中获得符号表symtab、字符串表strtab。
reloc_offset即是传入的参数reloc_arg，其代表在plt表中的第几项，保存在reloc中。
reloc的r_offset表示需要修改的函数地址在GOT表中的地址，加上装载地址l_addr得到的rel_addr就是函数的绝对地址。
接下来的st_other描述符号的可见性，如果包含STV_PROTECTED、STV_HIDDEN和STV_INTERNAL的其中任何一种，则直接将装载地址加上st_value即得到函数的最终地址value，将其写入rel_addr即可。
大部分情况下，会进入if语句，首先获得符号的version信息，然后调用_dl_lookup_symbol_x函数从已装载的共享库中查找最终的符号地址，查找到符号sym后，对其进行重定位，即加上装载地址，保存在value中。
最后调用elf_machine_fixup_plt函数进行修正。

<img src="assets/image-20240119124159069.png" alt="image-20240119124159069" style="zoom:25%;" />

<img src="assets/image-20240119124210109.png" alt="image-20240119124210109" style="zoom:25%;" />

在程序和库第一次调用某个例程时,PLT项会调用运行时链接器来解析该例程的实际地址。然后,PLT项会直接跳转到例程的实际地址，因此在第一次调用之后，使用PLT的代价就是在例程调用时有一个额外的间接跳转,在调用返回时没有额外的代价。  

PLT中的第一项，称之为PLT0，是一段会调用动态链接器的特殊代码。在加载时，动态链接器会自动地将两个数值放置在GOT中。在GOT+4(GOT的第二个字)处放置用来标识特定库的代码,在GOT+8处放置动态链接器的符号解析例程的地址.  

PLT中的其余表项，称之为PLTn,每一个都是由GOT项中的间接跳转开始。每一个PLT项都有一个对应的GOT项,该GOT项被初始设置为指向PLT项中跟在jmp指令后面的push指令处(在PIC文件中这需要加载时重定位，但这里的符号查找开销并不大)。跟在跳转指令jmp后面的压栈指令push将一个重定位偏移量压人栈中，这个偏移量是类型为R_386JMP_SLOT（初始化GOT）的特殊重定位项在文件的重定位表中的偏移量。该重定位项的符号引用指向文件符号表中的符号，它的地址指向相应的GOT项。  

<img src="assets/image-20240119124227669.png" alt="image-20240119124227669" style="zoom:65%;" />

这种紧凑但相当复杂的方法意昧着程序或者库在第一次调用PLT项时，PLT项中的第一个跳转指令实际上没做什么，因为它所跳转到的GOT又会指回到这个PLT项。然后push指令将间接标识需要解析的符号和解析符号所需的GOT项的偏移量压人栈中，然后跳转到PLT0。在PLT0中的指令将另一个标明当前是哪个程序或库的代码压人栈中，然后跳转到动态链接器的桩子代码(stub code)中(此时两个标识代码位于栈的顶部)。栈中位于两个标识字之上的是返回到调用该PLT的例程的地址.现在桩子代码保存所有的寄存器并调用动态链接器内部的例程来进行解析。栈中的两个标识字已经足以寻找库的符号表和例程在该符号表中对应的表项。动态链接器使用串联的运行时符号表来查找符号值,并将例程的地址存储在GOT项中。然后桩子代码恢复寄存器，将PLT压栈的两个标识码推出栈，然后跳转到这个例程中。这时GOT项已经更新了，后续对该PLT项的调用就无需通过动态链接器，而是直接跳转到例程本身。

***\*.got.plt\****相当于.plt的GOT全局偏移表, 其内容有两种情况, 

1)如果在之前查找过该符号, 内容为外部函数的具体地址. 

2)如果没查找过, 则内容为跳转回.plt的代码, 并执行查找.

.plt段，类似于一个后台查询接口

.got段，类似于数据库

.plt.got段，就类似于redis缓存。

## 笔记 from 逸翎清晗

1）汇编器生成一个目标模块时从地址0开始生成代码和数据节 ，它并不知道数据和代码最终将放在内存的什么位置，也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。
2）链接器在重定位步骤中，合并输入模块并将运行时地址赋给输入模块定义的每个节、符号。当这一步完成时，程序中的每条指令和全局变量才拥有唯一的运行时内存地址。

> **当一个模块引用一个外部定义的函数时，既然汇编器并不知道函数的最终内存位置，它要如何定位到这个函数？**

<img src="assets/v2-2ff78e7fee196d6969343a76c60e1914_720w-1709645180872-3.webp" alt="img" style="zoom:50%;" />

​	☆当汇编器遇到一个最终位置未知的引用时，它简单地将==立即数0x0==放入引用处，并==为这个引用生成一个重定位条目放在 .rel .text 中==(不在此具体叙述，可以理解为一个存放代码信息的数组)，而这个重定位条目拥有足够多的信息指导链接器在链接时将0x0修改为正确的数值，剩下的事就都交给**链接器**处理了。

<img src="assets/v2-30c540dda3da0977e3aeca207ebf8845_720w.webp" alt="img" style="zoom:50%;" />

<div style="color:blue">汇编器生成的代码 注意：编译器和汇编器从地址0开始生成代码和数据节，最终的内存位置由链接器确定，所以图中main从地址0开始</div>

<img src="assets/v2-c77478f4e0027cf850f6ba943b5f4af8_720w.webp" alt="img" style="zoom:50%;" />

<div style="color:blue">重定位条目结构</div>

> 1）**offset --> f**，f指立即数0x0位置的偏移量，即要**修改的引用位置**离main的偏移量
> 2）**type --> RX86_64PC32***，*重定位条目一共有32种type，R_X86_64_PC32表明重定位的引用使用32位PC相对地址
> 3）**symbol --> sum**，表明调用的符号是sum，在本例中是个函数
> 4）**addend --> -0x4**，这个addend可能会带来疑惑，它代表**引用位置与下一条指令的相对位置**关系，在此例中就是引用的偏移量 0xf 减去下一指令的偏移量 0x13 得到 -0x4，在链接器进行具体计算时我们需要用到它

现在万事俱备，只欠东风，我们要解决另一个关键问题--**链接器如何进行最后的运算？**我们知道在链接时，==链接器已经赋予了main和sum运行时地址==，现在我们要利用它们结合重定位条目的信息**计算并修改引用位置的0x0**。

<img src="assets/v2-eecec45e46fac950b1473ed16ac77a15_720w.webp" alt="img" style="zoom:50%;" />

如上图和前文所示，refptr是指向引用的指针，refaddr是引用的运行时地址，ADDR(r.symbol)是sum的运行时地址，r.addend是引用和下一条指令的相对位置。注意，第二个if语句针对使用绝对地址的引用，不在我们这个例子的考虑范围内。让我们把目光再次集中到图1的第5行代码，以这个例子的具体运算进行演示。

<img src="assets/v2-9a0341f8557382176098fb5db8ee0e4f_720w.webp" alt="img" style="zoom:50%;" />

由图可知：
main的运行时地址 ADDR(S) = `0x04004d0`
sum的运行时地址 ADDR(r.symbol) = `0x4004e8`
引用的运行时地址 refaddr = ADDR(S) + r.offset = `0x4004df`(0x5的位置)
callq下一指令运行时地址 = 0x4004e3 = refaddr - r.addend
根据图4的重定位算法，我们将修改0x0为0x5，这正是图1引用处的最终值

> 现在让我们利用处理器进行相对寻址的过程来理解和验证上述重定位算法
> **当CPU执行callq指令时，PC的值为0x4004e3，即callq的下一指令地址**(在处理器中，callq进入执行阶段，下一指令进入取址阶段)，为了执行callq指令，CPU将执行以下步骤：
> 1）将PC压入栈中
> 2）**更新 PC <-- PC + 0x5 = 0x4004e3 + 0x5 = 0x4004e8**

显然0x5是我们的重定位算法最后放在引用处的值，它对应于 sum 的运行时地址 减去 callq 下一指令的运行时地址，即：**ADDR(r.symbol) - (refaddr - r.addend)**
可以看到，以上过程与重定位算法有完美的一致性～

以上便是完整的链接重定位过程。

## 笔记2

重定位分为对==定义符号==的重定位和对==引用符号==的重定位，定义符号新的地址只需要加上所在段的新的偏移地址即可，而引用符号的重定位需要用到重定位表与符号表。

### 重定位表与符号表

对于可重定位的ELF文件来说，它必须包含有重定位表，用来描述如何修改相应的段里的内容。对于每个要重定位的ELF段都有一个对应的==重定位表，而一个重定位表往往就是ELF文件中的一个段==，所以其实重定位表也可以叫重定位段。

通过命令可以查看目标文件的重定位表。

![img](assets/16149fd6eb0f4bc8-9684787.)

OFFSET是重定位的入口偏移，表示该入口在要被重定位的段中的位置。“.text”表示这个重定位表示代码段的重定位表，所以偏移表示代码段中需要被调整的位置。这里的0x1c和0x27分别就是代码段中“mov”指令和“call”指令的地址部分。

重定位过程也伴随着符号的解析过程，每个目标文件都可能定义一些符号，也可能引用到定义在其他目标文件的符号。重定位的过程中，每个重定位的入口都是对一个符号的引用，那么当链接器需要对某个符号的引用进行重定位时，它就要确定这个符号的目标地址。这时候链接器就会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后进行重定位。

通过命令查看“a.o”的符号表。

![img](assets/16149fd6eb3c2da0)

可以看到shared和swap的类型都是“UND”，即“undefined”未定义类型，在链接器扫描完所有的输入目标文件后，所有这些未定义的符号都应该能够在全局符号表中找到，否则链接器就报符号未定义错误。这种一般都是链接时缺少了某些库，或者输入目标文件路径不正确或符号的声明与定义不一样。

### 重定位模式（指令修改方式）

不同的处理器指令对于地址的格式和方式都不一样。对于32位x86平台下的ELF文件的重定位入口所修正的指令寻址方式只有两种：

- 绝对近址32位寻址。
- 相对近址32位寻址。

这两种重定位方式指令修正方式每个被修正的位置的长度都是32位。这两种方式的定义：
![img](assets/16149fd6ec6f754d)

![img](assets/16149fd6eac47fa0)

“main”的起始地址为0x00000000，这是因为在未进行空间分配之前，目标文件代码段中的起始地址以0x00000000开始，等到空间分配完成以后，各个函数才会确定自己在虚拟地址空间中的位置。

偏移为0x18的地址上是==一条mov指令==，总共8个字节，它的作用是将“shared”的地址赋值到esp寄存器+4的偏移地址中去，前面4个字节“c7442404”是mov的指令码，后面4个字节是“shared”的地址。

偏移为0x26的地址上是==一条调用指令==，它表示对swap函数的调用。这条指令共5个字节，前面的0xe8是操作码，这是一条近址相对位移调用指令，后面4个字节就是被调用函数的相对于调用指令的下一条指令的偏移量。在没有重定位之前，相对偏移被置为0xFFFFFFFC（小端），它是常量“-4”的补码形式。

通过前面的重定位表可以看到swap符号的类型为R_386_PC32，这是一条相对位移调用指令。而shared符号的类型为R_386_32，它修正的是一条传输指令的源，即shared的绝对地址。

假设在将a.o和b.o链接成最终可执行文件后，main函数的虚拟地址为0x1000，swap函数的虚拟地址为0x2000，shared变量的虚拟地址为0x3000。

首先看偏移为0x18的这条mov指令的修正，它是绝对寻址修正，它修正后的结果是S+A。

- S是符号shared的实际地址，即0x3000。
- A是被修正位置的值，即0x00000000。

所以它的修正后的地址为：0x3000+0x00000000=0x3000。

![img](assets/16149fd6ec61a3b5)

再来看偏移为0x26的这条call指令的修正，它是相对寻址修正，它修正后的结果是S+A-P。

- S是符号swap的实际地址，即0x2000。
- A是被修正位置的值，即0xFFFFFFFC(-4)。
- P为被修正的位置，当链接成可执行文件时，这个值应该是被修正位置的虚拟地址，即0x1000+0x27。

所以它的修正后的地址为0x2000+(-4)-(0x1000+0x27)=0xFD5。	

## 附录

### Section1 LLVM-LLD,GCC-LD

- 编写文件simple_add.c

- 使用LLVM生成.o文件`clang -g -c -O0 simple_add.c -o simple_add.o`

- ```shell
	gdb --args "/usr/bin/ld" --eh-frame-hdr -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o a.out /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crt1.o /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crti.o /usr/lib/gcc/x86_64-redhat-linux/8/crtbegin.o -L/usr/lib/gcc/x86_64-redhat-linux/8 -L/usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64 -L/lib/../lib64 -L/usr/lib/../lib64 -L/usr/local/bin/../lib -L/lib -L/usr/lib ./simple_add.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-redhat-linux/8/crtend.o /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crtn.o
	```

	  可以调试LD

- ```shell
	clang -g -v -O0 simple_add.c
	```

	 打印流程

- ```shell
	CC=clang CXX=clang++ clang -g -v -O0 -fuse-ld=lld simple_add.c
	```

	 获取LLD流程

- ```shell
	gdb --args "/usr/local/bin/ld.lld" --eh-frame-hdr -m elf_x86_64 -dynamic-linker /lib64/ld-linux-x86-64.so.2 -o a.out /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crt1.o /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crti.o /usr/lib/gcc/x86_64-redhat-linux/8/crtbegin.o -L/usr/lib/gcc/x86_64-redhat-linux/8 -L/usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64 -L/lib/../lib64 -L/usr/lib/../lib64 -L/usr/local/bin/../lib -L/lib -L/usr/lib ./simple_add.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-redhat-linux/8/crtend.o /usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crtn.o
	```

### Section2 .a .o .so

| .a   | .o   | .so  |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |

### Section3 readelf,objdump

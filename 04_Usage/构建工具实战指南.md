# 构建工具实战指南

## 零  概要（必看）⭐⭐⭐

> 本文基于C++/C语言，整理了常见构建工具
>
> 此外，按照构建工具是否通过自动生成Makefile文件并借助make执行命令，**分类**为两组：0.1节与0.2节
>
> **目录**结构为 Make MakeFile CMake 的顺序

### 0.1 基于Makefile的工具

1. **CMake**：可以生成`Makefile`，也可以生成其他构建系统的配置文件（如Ninja的`build.ninja`）。
2. **Autoconf**：通过`configure`脚本生成`Makefile`。

编译流程图如下：

**虚线**表示直接使用`makefile`构建项目的过程

**实线**表示借助`cmake、Autoconf`构建项目的过程

![image-20240623123156922](https://img.zimei.fun/202406231231081.png)

**简要介绍**

**一、CMake**

**优点:**

- **跨平台:** 提供良好的跨平台支持（Windows, macOS, Linux）。
- **简化配置:** 配置文件（CMakeLists.txt）相对简单易读。
- **集成 IDE:** 支持生成多种 IDE 工程文件（如 Visual Studio, Xcode）。
- **广泛使用:** 在==**现代** C++ 项目==中非常流行，特别是在开源社区。

**缺点:**

- **调试难度:** CMake 脚本的调试不如传统的 Makefile 直观。

![image-20240623111651202](https://img.zimei.fun/202406231116293.png)

**二、GNU Autotools家族（Autoconf）**

**优点:**

- **广泛使用:** 历史悠久，很多==**老**的C/C++项目==依赖它。
- **灵活:** 可以处理复杂的构建需求。

**缺点:**

- **复杂性:** 学习曲线较陡峭，配置文件（configure.ac 和 Makefile.am）编写复杂。
- **依赖性:** 需要依赖于其他工具（如 Automake 和 Libtool），增加了构建系统的复杂性。
- **平台依赖性:** 对 Windows 的支持较差，主要适用于 Unix-like 系统。

![在这里插入图片描述](https://img.zimei.fun/202406231117231.png)

### 0.2 其他工具

1. **Ninja**：使用自己的`build.ninja`文件进行构建，不依赖于`Makefile`。
2. **Bazel**：使用自己的`BUILD`文件进行构建，不依赖于`Makefile`。
3. **Meson**：生成用于Ninja的`build.ninja`文件，不生成`Makefile`。
4. **SCons**：直接使用`SConstruct`文件进行构建，不生成`Makefile`。

**简要介绍**

- Ninja：是一个小巧且高效的构建系统，设计用来处理大量的小型文件编译任务，速度非常快。
- Bazel：是由 Google 开发的高性能构建系统，擅长处理大规模项目，特别适合复杂的依赖管理和跨平台构建。
- Meson：是一个以快速、高效和用户友好为目标的开源构建系统，主要用于编译 C、C++ 和其他语言的项目。
- SCons：是一个使用 Python 作为脚本语言的开源构建工具，旨在替代 Make 并简化构建过程。



## 一 Make

`make`（也被称为“构建”或“制作”）是一个用于自动化软件构建和部署的操作系统**命令行工具**。

通过解析称为Makefile的文件来执行构建任务。

目的是为了简化编译、链接和安装软件的过程。

## 二 MakeFile

`make`工具在构造项目的时候需要加载一个关系到了整个工程的编译规则的`makefile`的**文件**。

——自动化编译

### 1 规则⭐

> `Makefile`的框架是由规则构成的。`make`命令执行时先在`Makefile`文件中查找各种规则，对各种规则进行解析后运行规则。规则的基本格式为：

```makefile

target1,target2...: depend1, depend2, ...
	command
	......
	......
```

每条规则由三个部分组成分别是`目标(target)`, `依赖(depend)`和`命令(command)`。

> TIP
>
> 每个命令前必须有一个Tab缩进并且独占占一行
>
> 依赖可以为空
>
> 规则可以嵌套

例子如下：

```makefile
# 举例: 有源文件 a.c b.c c.c head.h, 需要生成可执行程序 app
################# 例1 #################
app:a.c b.c c.c
	gcc a.c b.c c.c -o app
	
################# 例2 #################
# 有多个目标, 多个依赖, 多个命令
app,app1:a.c b.c c.c d.c
	gcc a.c b.c -o app
	gcc c.c d.c -o app1
	
################# 例3 #################	
# 规则之间的嵌套
app:a.o b.o c.o
	gcc a.o b.o c.o -o app #依赖a.o b.o c.o此时并不存在，会主动寻找其他规则
# a.o 是第一条规则中的依赖
a.o:a.c
	gcc -c a.c
# b.o 是第一条规则中的依赖
b.o:b.c
	gcc -c b.c
# c.o 是第一条规则中的依赖
c.o:c.c
	gcc -c c.c
```

### 2 工作原理

#### 2.1 规则的执行

在调用 make 命令编译程序的时候，make 会首先找到 Makefile 文件中的第 1 个规则，分析并执行相关的动作。若第一条规则依赖不存在，会主动寻找其他规则。

> TIP
>
> 如果想要执行 makefile 中非第一条规则对应的命令, 那么就不能直接 `make`, 
>
> 需要将那条规则的目标也写到 make的后边, 例如: `make b.o`。

#### 2.2 文件的时间戳（了解）

make 命令执行的时候会根据文件的时间戳判定是否执行makefile文件中相关规则中的命令。

*   `目标时间戳 > 所有依赖的时间戳`规则中的命令就不会被执行。
*   `目标时间戳 < 某些依赖的时间戳`规则中的命令被重新生成。
*   如果规则中的目标对应的文件根本就不存在， 那么规则中的命令肯定会被执行。

#### 2.3 自动推导（了解）

场景：新手可能会漏写一些构建规则，程序依旧会被编译成功。

原因：make 有自动推导的能力，不会完全依赖 makefile。

假设本地项目目录中有以下几个源文件:

```shell
$ tree
.
├── add.c
├── div.c
├── head.h
├── main.c
├── makefile
├── mult.c
└── sub.c
```

目录中 makefile 文件内容如下

```makefile
# 这是一个完整的 makefile 文件
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
```

通过make构建项目:

```shell
$ make
cc    -c -o add.o add.c
cc    -c -o div.o div.c
cc    -c -o main.o main.c
cc    -c -o mult.o mult.c
cc    -c -o sub.o sub.c
gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
```

> 我们可以发现上边的 makefile 文件中只有一条规则, 依赖中所有的 `.o`文件在本地项目目录中是不存在的, 并且也没有其他的规则用来生成这些依赖文件, 这时候 make 会使用内部默认的构造规则先将这些依赖文件生成出来, 然后在执行规则中的命令, 最后生成目标文件 calc。

### 3 变量⭐

> 使用 `Makefile` 进行规则定义的时候，使用变量让书写灵活。
>
> `makefile`中的变量分为三种：`自定义变量`，`预定义变量`和`自动变量`。

#### 3.1 自定义变量（参考shell语法）

> 用 `Makefile` 进行规则定义的时候，用户可以定义自己的变量，称为用户自定义变量。`makefile` 中的变量是没有类型的，直接创建变量然后给其赋值就可以了。

```makefile
# 错误, 只创建了变量名, 没有赋值
变量名 
# 正确, 创建一个变量名并且给其赋值
变量名=变量值
```

在给`makefile`中的变量赋值之后, 如何在需要的时候将变量值取出来呢?

```makefile
# 如果将变量的值取出?
$(变量的名字)

# 举例 add.o  div.o  main.o  mult.o  sub.o
# 定义变量并赋值
obj=add.o  div.o  main.o  mult.o  sub.o
# 取变量的值
$(obj)
```

自定义变量使用举例：

```makefile
# 这是一个规则，普通写法
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
        
# 这是一个规则，里边使用了自定义变量
obj=add.o  div.o  main.o  mult.o  sub.o
target=calc
$(target):$(obj)
        gcc  $(obj) -o $(target)
```

#### 3.2 预定义变量

> 在 `Makefile` 中有一些已经定义的变量，用户可以直接使用这些变量，不用进行定义。在进行编译的时候，某些条件下 Makefile 会使用这些预定义变量的值进行编译。这些预定义变量的名字一般都是大写的，经常采用的预定义变量如下表所示：

| 变 量 名   | 含 义                           | 默 认 值 |
| ---------- | ------------------------------- | -------- |
| AR         | 生成静态库库文件的程序名称      | ar       |
| AS         | 汇编编译器的名称                | as       |
| ==CC==     | C 语言编译器的名称              | cc       |
| CPP        | C 语言预编译器的名称            | $(CC) -E |
| ==CXX==    | C++语言编译器的名称             | g++      |
| FC         | FORTRAN 语言编译器的名称        | f77      |
| RM         | 删除文件程序的名称              | rm -f    |
| ARFLAGS    | 生成静态库库文件程序的选项      | 无默认值 |
| ASFLAGS    | 汇编语言编译器的编译选项        | 无默认值 |
| ==CFLAGS== | C 语言编译器的编译选项（-o/-g） | 无默认值 |
| CPPFLAGS   | C 语言预编译的编译选项          | 无默认值 |
| CXXFLAGS   | C++语言编译器的编译选项         | 无默认值 |
| FFLAGS     | FORTRAN 语言编译器的编译选项    | 无默认   |

```makefile
# 这是一个规则，普通写法
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
        
# 这是一个规则，里边使用了自定义变量和预定义变量
obj=add.o  div.o  main.o  mult.o  sub.o
target=calc
CFLAGS=-O3 # 代码优化
$(target):$(obj)
        $(CC)  $(obj) -o $(target) $(CFLAGS)
```

#### 3.3 自动变量

> `Makefile` 中的变量除了用户自定义变量和预定义变量外，还有一类自动变量。`Makefile` 中的规则语句中经常会出现目标文件和依赖文件，`自动变量用来代表这些规则中的目标文件和依赖文件，并且它们只能在规则的命令中使用。`
>
> 下表中是一些常见的自动变量。

| 变 量  | 含 义                                                        |
| ------ | ------------------------------------------------------------ |
| $*     | 表示目标文件的名称，**不包含**目标文件的**扩展名**           |
| $+     | 表示所有的依赖文件，这些依赖文件之间以空格分开，按照出现的先后为顺序，其中可能 **包含重复**的**依赖文件** |
| ==$<== | 表示依赖项中第一个依赖文件的名称                             |
| $?     | 依赖项中，所有比目标文件时间戳晚的依赖文件，依赖文件之间以空格分开 |
| ==$@== | 表示目标文件的名称，**包含**文件**扩展名**                   |
| ==$^== | 依赖项中，所有**不重复**的**依赖文件**，这些文件之间以空格分开 |

下面几个例子, 演示一下自动变量如何使用。

```makefile
# 这是一个规则，普通写法
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
        
# 这是一个规则，里边使用了自定义变量
# 使用自动变量, 替换相关的内容
calc:add.o  div.o  main.o  mult.o  sub.o
	gcc $^ -o $@ 			# 自动变量只能在规则的命令中使用
```

### 4 模式匹配⭐

在介绍概念之前, 先读一下下面的这个 makefile 文件:

```makefile
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc
# 语法格式重复的规则, 将 .c -> .o, 使用的命令都是一样的 gcc *.c -c
add.o:add.c
        gcc add.c -c

div.o:div.c
        gcc div.c -c

main.o:main.c
        gcc main.c -c

sub.o:sub.c
        gcc sub.c -c

mult.o:mult.c
        gcc mult.c -c
```

在阅读过程中能够发现从第二个规则开始到第六个规则做的是相同的事情, 但是由于文件名不同不得不在文件中写出多个规则，这就让 makefile 文件看起来非常的冗余，我们可以将这一系列的相同操作整理成一个模板，所有类似的操作都通过模板去匹配 makefile 会因此而精简不少，只是可读性会有所下降。

这个规则模板可以写成下边的样子，这种操作就称之为模式匹配。

```makefile
# 模式匹配 -> 通过一个公式, 代表若干个满足条件的规则
# 依赖有一个, 后缀为.c, 生成的目标是一个 .o 的文件, 
# ⭐% 是一个通配符, 匹配的是文件名
%.o:%.c
	gcc $< -c
```

![](https://img.zimei.fun/202406201728100.png)

### 5 函数⭐

> `makefile`中有很多函数并且`所有的函数都是有返回值的。``makefile`中函数的格式和`C/C++`中函数也不同，其写法是这样的： `$(函数名 参数1, 参数2, 参数3, ...)`，主要目的是快速方便的得到函数的返回值。
>
> 这里为大家介绍两个 `makefile` 中使用频率比较高的函数：`wildcard`和`patsubst`。

#### 5.1 wildcard

这个函数的主要作用是获取指定目录下指定类型的文件名，其返回值是以空格分割的、指定目录下的所有符合条件的文件名列表。函数原型如下：

```makefile
# 该函数的参数只有一个, 但是这个参数可以分成若干个部分, 通过空格间隔
# ⭐* 是全局匹配符，用来表示全局的.c文件
$(wildcard PATTERN...)
	参数:	指定某个目录, 搜索这个路径下指定类型的文件，比如： *.c
```

*   参数功能:
    
    *   PATTERN 指的是某个或多个目录下的对应的某种类型的文件, 比如`当前目录下的.c`文件可以写成 `*.c`
    *   可以指定多个目录，每个路径之间使用空格间隔
*   返回值：
    
    *   得到的若干个文件的文件列表， 文件名之间使用空格间隔
    *   示例：`$(wildcard *.c ./sub/*.c)`
        *   返回值格式: a.c b.c c.c d.c e.c f.c ./sub/aa.c ./sub/bb.c

函数使用举例:

```makefile
# 使用举例: 分别搜索三个不同目录下的 .c 格式的源文件
src = $(wildcard /home/robin/a/*.c /home/robin/b/*.c *.c)  # *.c == ./*.c
# 返回值: 得到一个大的字符串, 里边有若干个满足条件的文件名, 文件名之间使用空格间隔
/home/robin/a/a.c /home/robin/a/b.c /home/robin/b/c.c /home/robin/b/d.c e.c f.c
```

#### 5.2 patsubst

这个函数的功能是按照指定的模式替换指定的文件名的后缀, 函数原型如下:

```makefile
# 有三个参数, 参数之间使用 逗号间隔
$(patsubst <pattern>,<replacement>,<text>)
```

*   参数功能:
    *   pattern: 这是一个模式字符串, 需要指定出要被替换的文件名中的后缀是什么
        *   文件名和路径不需要关心, 因此使用 % 表示即可 \[通配符是 %\]
        *   在通配符后边指定出要被替换的后缀, 比如: %.c, 意味着 .c的后缀要被替换掉
    *   replacement: 这是一个模式字符串, 指定参数pattern中的后缀最终要被替换为什么
        *   还是使用 % 来表示参数pattern 中文件的路径和名字
        *   在通配符 % 后边指定出新的后缀名, 比如: %.o 这表示原来的后缀被替换为 .o
    *   text: 该参数中存储这要被替换的原始数据
    *   返回值:
        *   函数返回被替换过后的字符串。

函数使用举例:

```makefile
src = a.cpp b.cpp c.cpp e.cpp
# 把变量 src 中的所有文件名的后缀从 .cpp 替换为 .o
obj = $(patsubst %.cpp, %.o, $(src)) 
# obj 的值为: a.o b.o c.o e.o
```

### 6 makefile的编写（项目实战）⭐

> 下面基于一个简单的项目, 为大家演示一下编写一个makefile从不标准到标准的进化过程。

```shell
# 项目目录结构
.
├── add.c
├── div.c
├── head.h
├── main.c
├── mult.c
└── sub.c
# 需要编写makefile对该项目进行自动化编译
```

#### 6.1 版本1

```makefile
calc:add.c  div.c  main.c  mult.c  sub.c
        gcc add.c  div.c  main.c  mult.c  sub.c -o calc
```

这个版本的优点：书写简单

这版本的缺点：只要依赖中的某一个源文件被修改，所有的源文件都需要被重新编译，太耗时、效率低

改进方式（版本2）：提高效率，修改哪一个源文件, 哪个源文件被重新编译, 不修改就不重新编译

#### 6.2 版本2

```makefile
# 默认所有的依赖都不存在, 需要使用其他规则生成这些依赖
# 因为 add.o 被更新, 需要使用最新的依赖, 生成最新的目标
calc:add.o  div.o  main.o  mult.o  sub.o
        gcc  add.o  div.o  main.o  mult.o  sub.o -o calc

# 如果修改了add.c, add.o 被重新生成
# 下面这些可以省去（见2.3 自动推导）
add.o:add.c
        gcc add.c -c

div.o:div.c
        gcc div.c -c

main.o:main.c
        gcc main.c -c

sub.o:sub.c
        gcc sub.c -c

mult.o:mult.c
        gcc mult.c -c
```

这个版本的优点：相较于版本1效率提升了

这个版本的缺点：规则比较冗余, 需要精简

改进方式：在 makefile 中使用变量 和 模式匹配

#### 6.3 版本3（引入 变量 模式匹配）

```makefile
# 添加自定义变量 -> makefile中注释前 使用 # 
obj=add.o  div.o  main.o  mult.o  sub.o
target=calc

$(target):$(obj)
        gcc $(obj)  -o $(target)

%.o:%.c
        gcc $< -c
```

这个版本的优点：文件精简不少，变得简洁了

这个版本的缺点：变量 obj 的值需要手动的写出来, 如果需要编译的项目文件很多，都用手写出来不现实

改进方式：在makefile中使用函数

#### 6.4 版本4（引入 函数）

```makefile
# 添加自定义变量 -> makefile中注释前 使用 # 
# %是通配符，用来通用匹配的。*是全局匹配符，用来表示全局的.c文件
# 使用函数搜索当前目录下的源文件 .c
src=$(wildcard *.c)
# 将源文件的后缀替换为 .o
# % 匹配的内容是不能被替换的, 需要替换的是第一个参数中的后缀, 替换为第二个参数中指定的后缀
# obj=$(patsubst %.cpp, %.o, $(src)) 将src中的关键字 .cpp 替换为 .o
obj=$(patsubst %.c, %.o, $(src))
target=calc

$(target):$(obj)
        gcc $(obj)  -o $(target)

%.o:%.c
        gcc $< -c
```

这个版本的优点：解决了自动加载项目文件的问题，解放了双手

这个版本的缺点：没有文件删除的功能，不能删除项目编译过程中生成的目标文件（*.o）和可执行程序

改进方式: 在makefile文件中添加新的规则用于删除生成的目标文件（*.o）和可执行程序

#### 6.5 版本5（强制生成）

```makefile
# 添加自定义变量 -> makefile中注释前 使用 # 
# 使用函数搜索当前目录下的源文件 .c
src=$(wildcard *.c)
# 将源文件的后缀替换为 .o
obj=$(patsubst %.c, %.o, $(src))
target=calc
# obj 的值 xxx.o xxx.o xxx.o xx.o
$(target):$(obj)
        gcc $(obj)  -o $(target)

%.o:%.c
        gcc $< -c

# 添加规则, 删除生成文件 *.o 可执行程序
# 这个规则比较特殊, clean根本不会生成, 这是一个伪目标
clean:
        rm $(obj) $(target)
```

这个版本的优点: 添加了新的规则（16行）用于文件的删除, 直接 `make clean` 就可以执行规则中的删除命令了

这个版本的缺点: 在下面有具体的问题演示和分析

改进方式: 在makefile文件中声明 `clean`是一个伪目标，让 make 放弃对它的时间戳检测。

正常情况下这个版本的makefile是可以正常工作的，但是我们如果在这个项目目录中添加一个叫做`clean`的文件（和规则中的目标名称相同），再进行 `make clean`发现这个规则就不能正常工作了。

```makefile
# 在项目目录中添加一个叫 clean的文件, 然后在 make clean 这个规则中的命令就不工作了
$ ls
add.c  calc   div.c  head.h  main.o    mult.c  sub.c
add.o  div.o  main.c  makefile  mult.o  sub.o  clean  ---> 新添加的

# 使用 makefile 中的规则删除生成的目标文件和可执行程序
$ make clean
make: 'clean' is up to date. 

# 查看目录, 发现相关文件并没有被删除, make clean 失败了
$ ls
add.c  calc   div.c  head.h  main.o    mult.c  sub.c
add.o  clean  div.o  main.c  makefile  mult.o  sub.o
```

这个问题的关键点在于 `clean`是一个伪目标, 不对应任何实体文件, 在前边讲`关于文件时间戳更新`问题的时候说过，如果目标不存在规则的命令肯定被执行， 如果目标文件存在了就需要比较规则中目标文件和依赖文件的时间戳，满足条件才执行规则的命令，否则不执行。

**解决这个问题**需要在 makefile 中声明 `clean`是一个伪目标，这样 make 就不会对文件的时间戳进行检测，规则中的命令也就每次都会被执行了。

在 makefile 中声明一个伪目标需要使用 `.PHONY` 关键字, 声明方式为: `.PHONY:伪文件名称`

#### 6.6 最终版代码⭐⭐

```makefile
# 添加自定义变量 -> makefile中注释前 使用 # 
# 使用函数搜索当前目录下的源文件 .c
src=$(wildcard *.c)
# 将源文件的后缀替换为 .o
obj=$(patsubst %.c, %.o, $(src))
target=calc

$(target):$(obj)
        gcc $(obj)  -o $(target)

%.o:%.c
        gcc $< -c

# 添加规则, 删除生成文件 *.o 可执行程序
# 声明clean为伪文件
.PHONY:clean
clean:
        # shell命令前的 - 表示强制这个指令执行, 如果执行失败也不会终止。（默认第一条命令执行失败，后续直接终止）
        -rm $(obj) $(target) 
        echo "hello, 我是测试字符串"
```

### 7 练习题

> 如果觉得上边讲的内容看懂了, 可以试着根据这个目录结构写出其对应的 makefile 文件。

```shell
# 目录结构
.
├── include
│   └── head.h	==> 头文件, 声明了加减乘除四个函数
├── main.c		==> 测试程序, 调用了head.h中的函数
└── src
    ├── add.c	==> 加法运算
    ├── div.c	==> 除法运算
    ├── mult.c  ==> 乘法运算
    └── sub.c   ==> 减法运算
```

根据上边的项目目录结构编写的makefile文件如下:

```makefile
# 最终的目标名 app
target = app
# 搜索当前项目目录下的源文件
src=$(wildcard *.c ./src/*.c)
# 将文件的后缀替换掉 .c -> .o
obj=$(patsubst %.c, %.o, $(src))
# 头文件目录
include=./include

# 第一条规则
# 依赖中都是 xx.o yy.o zz.o
# gcc命令执行的是链接操作
$(target):$(obj)
        gcc $^ -o $@

# 模式匹配规则
# 执行汇编操作, 前两步: 预处理, 编译是自动完成
%.o:%.c
        gcc $< -c -I $(include) -o $@

# 添加一个清除文件的规则
.PHONY:clean

clean:
        -rm $(obj) $(target) -f
```

## 三 CMake

### 1 CMake概述

CMake 是一个项目构建工具，可以看成一款自动生成 Makefile的工具。

`CMake`支持大写、小写、混合大小写的命令。如果在编写`CMakeLists.txt`文件时使用的工具有对应的命令提示，那么大小写随缘即可，不要太过在意。

### 2 Cmake的使用

#### 2.1 注释

##### 2.1.1 注释行

`CMake` 使用 `#` 进行`行注释`，可以放在任何位置。

```cmake
# 这是一个 CMakeLists.txt 文件
cmake_minimum_required(VERSION 3.0.0)
```

##### 2.1.2 注释块

`CMake` 使用 `#[[ ]]` 形式进行`块注释`。

```cmake
#[[ 这是一个 CMakeLists.txt 文件。
这是一个 CMakeLists.txt 文件
这是一个 CMakeLists.txt 文件]]
cmake_minimum_required(VERSION 3.0.0)
```

#### 2.1 只有源文件

##### 2.1.1 共处一室

1. 准备工作，为了方便测试，在我本地电脑准备了这么几个测试文件

   * **add.c**

     ```c++
     #include <stdio.h>
     #include "head.h"
     
     int add(int a, int b)
     {
         return a+b;
     }
     ```

   * **sub.c**

     ```c++
     #include <stdio.h>
     #include "head.h"
     
     
     int subtract(int a, int b)
     {
         return a-b;
     }
     ```

   * **mult.c**

     ```c++
     #include <stdio.h>
     #include "head.h"
     
     int multiply(int a, int b)
     {
         return a*b;
     }
     ```

   * **div.c**

     ```c++
     #include <stdio.h>
     #include "head.h"
     
     double divide(int a, int b)
     {
         return (double)a/b;
     }
     ```

   * **head.h**

     ```c++
     #ifndef _HEAD_H
     #define _HEAD_H
     // 加法
     int add(int a, int b);
     // 减法
     int subtract(int a, int b);
     // 乘法
     int multiply(int a, int b);
     // 除法
     double divide(int a, int b);
     #endif
     ```

   * **main.c**

     ```c++
     #include <stdio.h>
     #include "head.h"
     
     int main()
     {
         int a = 20;
         int b = 12;
         printf("a = %d, b = %d\n", a, b);
         printf("a + b = %d\n", add(a, b));
         printf("a - b = %d\n", subtract(a, b));
         printf("a * b = %d\n", multiply(a, b));
         printf("a / b = %f\n", divide(a, b));
         return 0;
     }
     ```

2. 上述文件的目录结构如下：

   ```shell
   $ tree
   .
   ├── add.c
   ├── div.c
   ├── head.h
   ├── main.c
   ├── mult.c
   └── sub.c
   ```

3. **添加 `CMakeLists.txt` 文件**

   在上述源文件所在目录下添加一个新文件 CMakeLists.txt，文件内容如下：

   ```cmake
   cmake_minimum_required(VERSION 3.0)
   project(CALC)
   add_executable(app add.c div.c main.c mult.c sub.c)
   ```

   接下来依次介绍一下在 CMakeLists.txt 文件中添加的三个命令:

   * `cmake_minimum_required`：指定使用的 cmake 的最低版本

     *   **可选，非必须，如果不加可能会有警告**

   * `project`：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是可以忽略的，只需要指定出工程名字即可。

     ```cmake
     # PROJECT 指令的语法是：
     project(<PROJECT-NAME> [<language-name>...])
     project(<PROJECT-NAME>
            [VERSION <major>[.<minor>[.<patch>[.<tweak>]]]]
            [DESCRIPTION <project-description-string>]
            [HOMEPAGE_URL <url-string>]
            [LANGUAGES <language-name>...])
     ```

   * `add_executable`：定义工程会生成一个可执行程序

     ```cmake
     add_executable(可执行程序名 源文件名称)
     ```

     * 这里的可执行程序名和`project`中的项目名没有任何关系

     * 源文件名可以是一个也可以是多个，如有多个可用空格或`;`间隔

       ```cmake
       # 样式1
       add_executable(app add.c div.c main.c mult.c sub.c)
       # 样式2
       add_executable(app add.c;div.c;main.c;mult.c;sub.c)。
       ```

4. 执行`CMake` 命令

   万事俱备只欠东风，将 CMakeLists.txt 文件编辑好之后，就可以执行 `cmake`命令了。

   ```shell
   # cmake 命令原型
   $ cmake CMakeLists.txt文件所在路径
   ```

   ```shell
   $ tree
   .
   ├── add.c
   ├── CMakeLists.txt
   ├── div.c
   ├── head.h
   ├── main.c
   ├── mult.c
   └── sub.c
   
   0 directories, 7 files
   robin@OS:~/Linux/3Day/calc$ cmake .
   ```

   当执行`cmake`命令之后，CMakeLists.txt 中的命令就会被执行，所以一定要注意给`cmake` 命令指定路径的时候一定不能出错。

   执行命令之后，看一下源文件所在目录中是否多了一些文件：

   ```shell
   $ tree -L 1
   .
   ├── add.c
   ├── CMakeCache.txt         # new add file
   ├── CMakeFiles             # new add dir
   ├── cmake_install.cmake    # new add file
   ├── CMakeLists.txt
   ├── div.c
   ├── head.h
   ├── main.c
   ├── Makefile               # new add file
   ├── mult.c
   └── sub.c
   ```

   我们可以看到在对应的目录下生成了一个`makefile`文件，此时再执行`make`命令，就可以对项目进行构建得到所需的可执行程序了。

   ```shell
   $ make
   Scanning dependencies of target app
   [ 16%] Building C object CMakeFiles/app.dir/add.c.o
   [ 33%] Building C object CMakeFiles/app.dir/div.c.o
   [ 50%] Building C object CMakeFiles/app.dir/main.c.o
   [ 66%] Building C object CMakeFiles/app.dir/mult.c.o
   [ 83%] Building C object CMakeFiles/app.dir/sub.c.o
   [100%] Linking C executable app
   [100%] Built target app
   
   # 查看可执行程序是否已经生成
   $ tree -L 1
   .
   ├── add.c
   ├── app					# 生成的可执行程序
   ├── CMakeCache.txt
   ├── CMakeFiles
   ├── cmake_install.cmake
   ├── CMakeLists.txt
   ├── div.c
   ├── head.h
   ├── main.c
   ├── Makefile
   ├── mult.c
   └── sub.c
   ```

   最终可执行程序`app`就被编译出来了（这个名字是在`CMakeLists.txt`中指定的）。

##### 2.1.2 VIP 包房⭐

通过上面的例子可以看出，如果在`CMakeLists.txt`文件所在目录执行了`cmake`命令之后就会生成一些目录和文件（`包括 makefile 文件`），如果再基于`makefile文件`执行`make`命令，程序在编译过程中还会生成一些中间文件和一个可执行文件，这样会导致整个项目目录看起来很混乱，不太容易管理和维护，此时我们就可以==把生成的这些与项目源码无关的文件统一放到一个对应的目录里边==，比如将这个目录命名为`build`:

```shell
$ mkdir build
$ cd build
$ cmake ..
-- The C compiler identification is GNU 5.4.0
-- The CXX compiler identification is GNU 5.4.0
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /home/robin/Linux/build
```

现在`cmake`命令是在`build`目录中执行的，但是`CMakeLists.txt`文件是`build`目录的上一级目录中，所以`cmake` 命令后指定的路径为`..`，即当前目录的上一级目录。

当命令执行完毕之后，在`build`目录中会生成一个`makefile`文件

```shell
$ tree build -L 1
build
├── CMakeCache.txt
├── CMakeFiles
├── cmake_install.cmake
└── Makefile

1 directory, 3 files
```

这样就可以在`build`目录中执行`make`命令编译项目，生成的相关文件自然也就被存储到`build`目录中了。这样通过`cmake`和`make`生成的所有文件就全部和项目源文件隔离开了，各回各家，各找各妈。

#### 2.2 私人订制

##### 2.2.1 定义变量⭐

在上面的例子中一共提供了5个源文件，假设这五个源文件需要反复被使用，每次都直接将它们的名字写出来确实是很麻烦，此时我们就需要定义一个变量，将文件名对应的字符串存储起来，在cmake里定义变量需要使用`set`。

```cmake
# SET 指令的语法是：
# [] 中的参数为可选项, 如不需要可以不写
SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])
```

*   `VAR`：变量名
*   `VALUE`：变量值

```cmake
# 方式1: 各个源文件之间使用空格间隔
# set(SRC_LIST add.c  div.c   main.c  mult.c  sub.c)

# 方式2: 各个源文件之间使用分号 ; 间隔
set(SRC_LIST add.c;div.c;main.c;mult.c;sub.c)
add_executable(app  ${SRC_LIST})
```

##### 2.2.2 指定使用的C++标准

在编写C++程序的时候，可能会用到C++11、C++14、C++17、C++20等新特性，那么就需要在编译的时候在编译命令中制定出要使用哪个标准，有些编译器默认C++98：

```shell
$ g++ *.cpp -std=c++11 -o app
```

上面的例子中通过参数`-std=c++11`指定出要使用c++11标准编译程序，C++标准对应有一宏叫做`DCMAKE_CXX_STANDARD`。在CMake中想要指定C++标准有两种方式：

1. 在 CMakeLists.txt 中通过 set 命令指定

   ```cmake
   #增加-std=c++11
   set(CMAKE_CXX_STANDARD 11)
   #增加-std=c++14
   set(CMAKE_CXX_STANDARD 14)
   #增加-std=c++17
   set(CMAKE_CXX_STANDARD 17)
   ```

2. 在执行 cmake 命令的时候指定出这个宏的值

   ```shell
   #增加-std=c++11
   cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=11
   #增加-std=c++14
   cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=14
   #增加-std=c++17
   cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=17
   ```

   在上面例子中 CMake 后的路径需要根据实际情况酌情修改。

##### 2.2.3 指定输出的路径

在CMake中指定可执行程序输出的路径，也对应一个宏，叫做`EXECUTABLE_OUTPUT_PATH`，它的值还是通过`set`命令进行设置:

```cmake
set(HOME /home/robin/Linux/Sort)
set(EXECUTABLE_OUTPUT_PATH ${HOME}/bin)
```

*   第一行：定义一个变量用于存储一个绝对路径
*   第二行：将拼接好的路径值设置给`EXECUTABLE_OUTPUT_PATH`宏
    *   **如果这个路径中的子目录不存在，会自动生成，无需自己手动创建**

由于可执行程序是基于 cmake 命令生成的 makefile 文件然后再执行 make 命令得到的，所以如果此处指定可执行程序生成路径的时候使用的是相对路径 ./xxx/xxx，那么这个路径中的 ./ 对应的就是 makefile 文件所在的那个目录。

#### 2.3 搜索文件⭐

如果一个项目里边的源文件很多，在编写`CMakeLists.txt`文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦也不现实。所以，在CMake中为我们提供了搜索文件的命令，可以使用`aux_source_directory`命令或者`file`命令。

##### 2.3.1 方式1

在 CMake 中使用`aux_source_directory` 命令可以查找某个路径下的`所有源文件`，命令格式为：

```cmake
aux_source_directory(< dir > < variable >)
```

*   `dir`：要搜索的目录
*   `variable`：将从`dir`目录下搜索到的源文件列表存储到该变量中

```cmake
cmake_minimum_required(VERSION 3.0)
project(CALC)
# 见2.4包含头文件
include_directories(${PROJECT_SOURCE_DIR}/include)
# 搜索 src 目录下的源文件
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SRC_LIST)
add_executable(app  ${SRC_LIST})
```

##### 2.3.2 方式2（递归）⭐

如果一个项目里边的源文件很多，在编写`CMakeLists.txt`文件的时候不可能将项目目录的各个文件一一罗列出来，这样太麻烦了。所以，在CMake中为我们提供了搜索文件的命令，他就是`file（当然，除了搜索以外通过 file 还可以做其他事情）`。

```cmake
file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型)
```

*   `GLOB`: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。
*   `GLOB_RECURSE`：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。

**搜索当前目录的src目录下所有的源文件，并存储到变量中**

```cmake
file(GLOB MAIN_SRC ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)
file(GLOB MAIN_HEAD ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h)
```

* CMAKE\_CURRENT\_SOURCE_DIR 宏表示当前访问的 CMakeLists.txt 文件所在的路径。

* 关于要搜索的文件路径和类型可加双引号，也可不加:

  ```cmake
  file(GLOB MAIN_HEAD "${CMAKE_CURRENT_SOURCE_DIR}/src/*.h")
  ```

#### 2.4 包含头文件⭐

在编译项目源文件的时候，很多时候都需要将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能够找到这些头文件，并顺利通过编译。在CMake中设置要包含的目录也很简单，通过一个命令就可以搞定了，他就是`include_directories`:

```cmake
include_directories(headpath)
```

#### 2.1-2.4最终版代码⭐⭐

举例说明，有源文件若干，其目录结构如下：

```c++
$ tree
.
├── build
├── CMakeLists.txt
├── include
│   └── head.h
└── src
    ├── add.cpp
    ├── div.cpp
    ├── main.cpp
    ├── mult.cpp
    └── sub.cpp

3 directories, 7 files
```

`CMakeLists.txt`文件内容如下:

```cmake
cmake_minimum_required(VERSION 3.0)
project(CALC)
# 指定C++标准
set(CMAKE_CXX_STANDARD 11)
# 定义变量HOME
set(HOME /home/robin/Linux/calc)
# 输出路径
set(EXECUTABLE_OUTPUT_PATH ${HOME}/bin/)
# 头文件对应的路径
include_directories(${PROJECT_SOURCE_DIR}/include)
# 递归搜索
file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)
# 定义工程会生成一个可执行程序
add_executable(app  ${SRC_LIST})
```

其中，第六行指定就是头文件的路径，`PROJECT_SOURCE_DIR`宏对应的值就是我们在使用cmake命令时，后面紧跟的目录，一般是工程的根目录。

#### 2.5 制作动态库或静态库⭐

有些时候我们编写的源代码并不需要将他们编译生成可执行程序，而是生成一些静态库或动态库提供给第三方使用，下面来讲解在cmake中生成这两类库文件的方法。

##### 2.5.1 制作静态库

在cmake中，如果要制作静态库，需要使用的命令如下：

```cmake
add_library(库名称 STATIC 源文件1 [源文件2] ...) 
```

在Linux中，静态库名字分为三部分：`lib`+`库名字`+`.a`，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。

在Windows中虽然库名和Linux格式不同，但也只需指定出名字即可。

下面有一个目录，需要将`src`目录中的源文件编译成静态库，然后再使用：

```shell
.
├── build
├── CMakeLists.txt
├── include           # 头文件目录
│   └── head.h
├── main.cpp          # 用于测试的源文件
└── src               # 源文件目录
    ├── add.cpp
    ├── div.cpp
    ├── mult.cpp
    └── sub.cpp
```

根据上面的目录结构，可以这样编写`CMakeLists.txt`文件:

```cmake
cmake_minimum_required(VERSION 3.0)
project(CALC)
include_directories(${PROJECT_SOURCE_DIR}/include)
file(GLOB SRC_LIST "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp")
add_library(calc STATIC ${SRC_LIST})
```

这样最终就会生成对应的静态库文件`libcalc.a`。

##### 2.5.2 制作动态库

在cmake中，如果要制作动态库，需要使用的命令如下：

```cmake
add_library(库名称 SHARED 源文件1 [源文件2] ...) 
```

在Linux中，动态库名字分为三部分：`lib`+`库名字`+`.so`，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充。

在Windows中虽然库名和Linux格式不同，但也只需指定出名字即可。

根据上面的目录结构，可以这样编写`CMakeLists.txt`文件:

```cmake
cmake_minimum_required(VERSION 3.0)
project(CALC)
include_directories(${PROJECT_SOURCE_DIR}/include)
file(GLOB SRC_LIST "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp")
add_library(calc SHARED ${SRC_LIST})
```

这样最终就会生成对应的动态库文件`libcalc.so`。

##### 2.5.3 指定输出的路径

###### 方式1 - 适用于动态库

对于生成的库文件来说和可执行程序一样都可以指定输出路径。`由于在Linux下生成的动态库默认是有执行权限的`，所以可以按照生成可执行程序的方式去指定它生成的目录：

```cmake
cmake_minimum_required(VERSION 3.0)
project(CALC)
include_directories(${PROJECT_SOURCE_DIR}/include)
file(GLOB SRC_LIST "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp")
# 设置动态库生成路径
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)
add_library(calc SHARED ${SRC_LIST})
```

对于这种方式来说，其实就是通过`set`命令给`EXECUTABLE_OUTPUT_PATH`宏设置了一个路径，这个路径就是可执行文件生成的路径。

###### 方式2 - 都适用

由于在Linux下生成的静态库默认不具有可执行权限，所以在指定静态库生成的路径的时候就不能使用`EXECUTABLE_OUTPUT_PATH`宏了，而应该使用`LIBRARY_OUTPUT_PATH`，这个宏对应静态库文件和动态库文件都适用。

```cmake
cmake_minimum_required(VERSION 3.0)
project(CALC)
include_directories(${PROJECT_SOURCE_DIR}/include)
file(GLOB SRC_LIST "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp")
# 设置动态库/静态库生成路径
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)
# 生成动态库
#add_library(calc SHARED ${SRC_LIST})
# 生成静态库
add_library(calc STATIC ${SRC_LIST})
```

#### 2.6 包含库文件

在编写程序的过程中，可能会用到一些系统提供的动态库或者自己制作出的动态库或者静态库文件，cmake中也为我们提供了相关的加载动态库的命令。

##### 2.6.1 链接静态库⭐

```shell
src
├── add.cpp
├── div.cpp
├── main.cpp
├── mult.cpp
└── sub.cpp
```

现在我们把上面`src`目录中的`add.cpp、div.cpp、mult.cpp、sub.cpp`编译成一个静态库文件`libcalc.a`。[通过命令制作并使用静态链接库](https://subingwen.cn/linux/library/#1-1-%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93 "通过命令制作并使用静态链接库")

测试目录结构如下：

```shell
$ tree 
.
├── build
├── CMakeLists.txt
├── include
│   └── head.h
├── lib
│   └── libcalc.a     # 制作出的静态库的名字
└── src
    └── main.cpp

4 directories, 4 files
```

在cmake中，链接静态库的命令如下：

```cmake
link_libraries(<static lib> [<static lib>...])
```

*   **参数1**：指定出要链接的静态库的名字
    *   可以是全名 `libxxx.a`
    *   也可以是掐头（`lib`）去尾（`.a`）之后的名字 `xxx`
*   **参数2-N**：要链接的其它静态库的名字

如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来：

```cmake
link_directories(<lib path>)
```

这样，修改之后的`CMakeLists.txt`文件内容如下:

```cmake
cmake_minimum_required(VERSION 3.0)
project(CALC)
# 搜索指定目录下源文件
file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)
# 包含头文件路径
include_directories(${PROJECT_SOURCE_DIR}/include)
# 包含静态库路径
link_directories(${PROJECT_SOURCE_DIR}/lib)
# 链接静态库
link_libraries(calc)
add_executable(app ${SRC_LIST})
```

添加了第8行的代码，就可以根据参数指定的路径找到这个静态库了。

==静态库，最终在生成可执行程序时，静态库与对应源文件都会被打包的对应的可执行程序里面==

##### 2.6.2 链接动态库

在程序编写过程中，除了在项目中引入静态库，好多时候也会使用一些标准的或者第三方提供的一些动态库，关于动态库的制作、使用以及在内存中的加载方式和静态库都是不同的，在此不再过多赘述，如有疑惑请参考[Linux 静态库和动态库](https://subingwen.cn/linux/library/ "Linux 静态库和动态库")

在`cmake`中链接动态库的命令如下:

```cmake
target_link_libraries(
    <target> 
    <PRIVATE|PUBLIC|INTERFACE> <item>... 
    [<PRIVATE|PUBLIC|INTERFACE> <item>...]...)
```

* **target**：指定要加载动态库的文件的名字

  *   该文件可能是一个源文件
  *   该文件可能是一个动态库文件
  *   该文件可能是一个可执行文件

* **PRIVATE|PUBLIC|INTERFACE**：动态库的访问权限，默认为`PUBLIC`

  * 如果各个动态库之间没有依赖关系，无需做任何设置，三者没有没有区别，一般无需指定，使用默认的 PUBLIC 即可。

  * `动态库的链接具有传递性`，如果动态库 A 链接了动态库B、C，动态库D链接了动态库A，此时动态库D相当于也链接了动态库B、C，并可以使用动态库B、C中定义的方法。

    ```cmake
    target_link_libraries(A B C)
    target_link_libraries(D A)
    ```

    *   `PUBLIC`：在public后面的库会被Link到前面的target中，并且里面的符号也会被导出，提供给第三方使用。
    *   `PRIVATE`：在private后面的库仅被link到前面的target中，并且终结掉，第三方不能感知你调了啥库
    *   `INTERFACE`：在interface后面引入的库不会被链接到前面的target中，只会导出符号。

###### 链接系统动态库

动态库的链接和静态库是完全不同的：

*   静态库会在生成可执行程序的链接阶段被打包到可执行程序中，所以可执行程序启动，静态库就被加载到内存中了。
*   动态库在生成可执行程序的链接阶段**不会**被打包到可执行程序中，当可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存

因此，在`cmake`中指定要链接的动态库的时候，`应该将命令写到生成了可执行文件之后：`

```cmake
cmake_minimum_required(VERSION 3.0)
project(TEST)
file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp)
# 添加并指定最终生成的可执行程序名
add_executable(app ${SRC_LIST})
# 指定可执行程序要链接的动态库名字
target_link_libraries(app pthread)
```

在`target_link_libraries(app pthread)`中：

*   `app:` 对应的是最终生成的可执行程序的名字
*   `pthread`：这是可执行程序要加载的动态库，这个库是系统提供的线程库，**全名为**`libpthread.so`，在指定的时候一般会**掐头**（lib）**去尾**（.so）。

###### 链接第三方动态库⭐

现在，自己生成了一个动态库，对应的目录结构如下：

```shell
$ tree 
.
├── build
├── CMakeLists.txt
├── include
│   └── head.h            # 动态库对应的头文件
├── lib
│   └── libcalc.so        # 自己制作的动态库文件
└── main.cpp              # 测试用的源文件

3 directories, 4 files
```

假设在测试文件`main.cpp`中既使用了自己制作的动态库`libcalc.so`又使用了系统提供的线程库，此时`CMakeLists.txt`文件可以这样写：

```cmake
cmake_minimum_required(VERSION 3.0)
project(TEST)
file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp)
include_directories(${PROJECT_SOURCE_DIR}/include)
add_executable(app ${SRC_LIST})
target_link_libraries(app pthread calc)
```

在**第六行**中，`pthread、calc`都是可执行程序`app`要链接的动态库的名字。当可执行程序`app`生成之后并执行该文件，会提示有如下错误信息：

```shell
$ ./app 
./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory
```

这是因为可执行程序启动之后，去加载`calc`这个动态库，但是不知道这个动态库被放到了什么位置[解决动态库无法加载的问题](https://subingwen.cn/linux/library/#2-4-1-%E5%BA%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86 "解决动态库无法加载的问题")，所以就加载失败了，在 CMake 中可以在生成可执行程序之前，通过命令指定出要链接的动态库的位置，指定静态库位置使用的也是这个命令：

```cmake
link_directories(path)
```

所以修改之后的`CMakeLists.txt`文件应该是这样的：

```cmake
cmake_minimum_required(VERSION 3.0)
project(TEST)
file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/*.cpp)
# 指定源文件或者动态库对应的头文件路径
include_directories(${PROJECT_SOURCE_DIR}/include)
# 指定要链接的动态库的路径
link_directories(${PROJECT_SOURCE_DIR}/lib)
# 添加并生成一个可执行程序
add_executable(app ${SRC_LIST})
# 指定要链接的动态库
target_link_libraries(app pthread calc)
```

通过`link_directories`指定了动态库的路径之后，在执行生成的可执行程序的时候，就不会出现找不到动态库的问题了。

温馨提示：使用 target\_link\_libraries 命令就可以链接动态库，也可以链接静态库文件。

#### 2.7 日志（调试）

在CMake中可以用用户显示一条消息，该命令的名字为`message`：

```cmake
message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR] "message to display" ...)
```

*   `(无)` ：重要消息
*   `STATUS` ：非重要消息
*   `WARNING`：CMake 警告, 会继续执行
*   `AUTHOR_WARNING`：CMake 警告 (dev), 会继续执行
*   `SEND_ERROR`：CMake 错误, 继续执行，但是会跳过生成的步骤
*   `FATAL_ERROR`：CMake 错误, 终止所有处理过程

CMake的命令行工具会在stdout上显示`STATUS`消息，在stderr上显示其他所有消息。CMake的GUI会在它的log区域显示所有消息。

CMake警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。

```cmake
# 输出一般日志信息
message(STATUS "source path: ${PROJECT_SOURCE_DIR}")
# 输出警告信息
message(WARNING "source path: ${PROJECT_SOURCE_DIR}")
# 输出错误信息
message(FATAL_ERROR "source path: ${PROJECT_SOURCE_DIR}")
```

#### 2.8 变量操作⭐

在变量里存储的所有数据默认都为字符串类型，所以**涉及大量字符串处理工作**

##### 2.8.1 追加

有时候项目中的源文件并不一定都在同一个目录中，但是这些源文件最终却需要一起进行编译来生成最终的可执行文件或者库文件。如果我们通过`file`命令对各个目录下的源文件进行搜索，最后还需要做一个字符串拼接的操作，关于字符串拼接可以使用`set`命令也可以使用`list`命令。

###### 使用set拼接

如果使用set进行字符串拼接，对应的命令格式如下：

```cmake
set(变量名1 ${变量名1} ${变量名2} ...)
```

关于上面的命令其实就是将从第二个参数开始往后所有的字符串进行拼接，最后将结果存储到第一个参数中，如果第一个参数中原来有数据会对原数据就行覆盖。

```cmake
cmake_minimum_required(VERSION 3.0)
project(TEST)
set(TEMP "hello,world")
file(GLOB SRC_1 ${PROJECT_SOURCE_DIR}/src1/*.cpp)
file(GLOB SRC_2 ${PROJECT_SOURCE_DIR}/src2/*.cpp)
# 追加(拼接)
set(SRC_1 ${SRC_1} ${SRC_2} ${TEMP})
message(STATUS "message: ${SRC_1}")
```

###### 使用list拼接

如果使用list进行字符串拼接，对应的命令格式如下：

```cmake
list(APPEND <list> [<element> ...])
```

`list`命令的功能比`set`要强大，字符串拼接只是它的其中一个功能，所以需要在它第一个参数的位置指定出我们要做的操作，`APPEND`表示进行数据追加，后边的参数和`set`就一样了。

```cmake
cmake_minimum_required(VERSION 3.0)
project(TEST)
set(TEMP "hello,world")
file(GLOB SRC_1 ${PROJECT_SOURCE_DIR}/src1/*.cpp)
file(GLOB SRC_2 ${PROJECT_SOURCE_DIR}/src2/*.cpp)
# 追加(拼接)
list(APPEND SRC_1 ${SRC_1} ${SRC_2} ${TEMP})
message(STATUS "message: ${SRC_1}")
```

在CMake中，使用`set`命令可以创建一个`list`。一个在`list`内部是一个由`分号;`分割的一组字符串。例如，`set(var a b c d e)`命令将会创建一个`list:a;b;c;d;e`，但是最终打印变量值的时候得到的是`abcde`。

```cmake
set(tmp1 a;b;c;d;e)
set(tmp2 a b c d e)
message(${tmp1})
message(${tmp2})
```

输出的结果:

```shell
abcde
abcde
```

##### 2.8.2 字符串移除

我们在通过`file`搜索某个目录就得到了该目录下所有的源文件，但是其中有些源文件并不是我们所需要的，比如：

```shell
$ tree
.
├── add.cpp
├── div.cpp
├── main.cpp
├── mult.cpp
└── sub.cpp

0 directories, 5 files
```

在当前这么目录有五个源文件，其中`main.cpp`是一个测试文件。如果我们想要把计算器相关的源文件生成一个动态库给别人使用，那么只需要`add.cpp、div.cp、mult.cpp、sub.cpp`这四个源文件就可以了。此时，就需要将`main.cpp`从搜索到的数据中剔除出去，想要实现这个功能，也可以使用`list`

```cmake
list(REMOVE_ITEM <list> <value> [<value> ...])
```

通过上面的命令原型可以看到删除和追加数据类似，只不过是第一个参数变成了`REMOVE_ITEM`。

```cmake
cmake_minimum_required(VERSION 3.0)
project(TEST)
set(TEMP "hello,world")
file(GLOB SRC_1 ${PROJECT_SOURCE_DIR}/*.cpp)
# 移除前日志
message(STATUS "message: ${SRC_1}")
# 移除 main.cpp
list(REMOVE_ITEM SRC_1 ${PROJECT_SOURCE_DIR}/main.cpp)
# 移除后日志
message(STATUS "message: ${SRC_1}")
```

可以看到，在`第8行`把将要移除的文件的名字指定给`list`就可以了。但是一定要注意通过 file 命令搜索源文件的时候得到的是文件的绝对路径（在list中每个文件对应的路径都是一个item，并且都是绝对路径），那么在移除的时候也要将该文件的绝对路径指定出来才可以，否是移除操作不会成功。

关于`list`命令还有其它功能，但是并不常用，在此就不一一进行举例介绍了。

1. 获取 list 的长度。

   ```cmake
   list(LENGTH <list> <output variable>)
   ```

   *   `LENGTH`：子命令LENGTH用于读取列表长度
   *   `<list>`：当前操作的列表
   *   `<output variable>`：新创建的变量，用于存储列表的长度。

2. 读取列表中指定索引的的元素，可以指定多个索引

   ```cmake
   list(GET <list> <element index> [<element index> ...] <output variable>)
   ```

   *   `<list>`：当前操作的列表
   *   `<element index>`：列表元素的索引
       *   从0开始编号，索引0的元素为列表中的第一个元素；
       *   索引也可以是负数，`-1`表示列表的最后一个元素，`-2`表示列表倒数第二个元素，以此类推
       *   当索引（不管是正还是负）超过列表的长度，运行会报错
   *   `<output variable>`：新创建的变量，存储指定索引元素的返回结果，也是一个列表。

3. 将列表中的元素用连接符（字符串）连接起来组成一个字符串

   ```cmake
   list (JOIN <list> <glue> <output variable>)
   ```

   *   `<list>`：当前操作的列表
   *   `<glue>`：指定的连接符（字符串）
   *   `<output variable>`：新创建的变量，存储返回的字符串

4. 查找列表是否存在指定的元素，若果未找到，返回-1

   ```cmake
   list(FIND <list> <value> <output variable>)
   ```

   *   `<list>`：当前操作的列表
   *   `<value>`：需要再列表中搜索的元素
   *   `<output variable>`：新创建的变量
       *   如果列表`<list>`中存在`<value>`，那么返回`<value>`在列表中的索引
       *   如果未找到则返回-1。

5. 将元素追加到列表中

   ```cmake
   list (APPEND <list> [<element> ...])
   ```

6. 在list中指定的位置插入若干元素

   ```cmake
   list(INSERT <list> <element_index> <element> [<element> ...])
   ```

7. 将元素插入到列表的0索引位置

   ```cmake
   list (PREPEND <list> [<element> ...])
   ```

8. 将列表中最后元素移除

   ```cmake
   list (POP_BACK <list> [<out-var>...])
   ```

9. 将列表中第一个元素移除

   ```cmake
   list (POP_FRONT <list> [<out-var>...])
   ```

10. 将指定的元素从列表中移除

    ```cmake
    list (REMOVE_ITEM <list> <value> [<value> ...])
    ```

11. 将指定索引的元素从列表中移除

    ```cmake
    list (REMOVE_AT <list> <index> [<index> ...])
    ```

12. 移除列表中的重复元素

    ```cmake
    list (REMOVE_DUPLICATES <list>)
    ```

13. 列表翻转

    ```cmake
    list(REVERSE <list>)
    ```

14. 列表排序

    ```cmake
    list (SORT <list> [COMPARE <compare>] [CASE <case>] [ORDER <order>])
    ```

    *   `COMPARE`：指定排序方法。有如下几种值可选：
        *   `STRING`:按照字母顺序进行排序，为默认的排序方法
        *   `FILE_BASENAME`：如果是一系列路径名，会使用basename进行排序
        *   `NATURAL`：使用自然数顺序排序
    *   `CASE`：指明是否大小写敏感。有如下几种值可选：
        *   `SENSITIVE`: 按照大小写敏感的方式进行排序，为默认值
        *   `INSENSITIVE`：按照大小写不敏感方式进行排序
    *   `ORDER`：指明排序的顺序。有如下几种值可选：
        *   `ASCENDING`:按照升序排列，为默认值
        *   `DESCENDING`：按照降序排列

#### 2.9 宏定义（调试）

在进行程序测试的时候，我们可以在代码中添加一些宏定义，通过这些宏来控制这些代码是否生效，如下所示：

```c++
#include <stdio.h>
#define NUMBER  3

int main()
{
    int a = 10;
#ifdef DEBUG
    printf("我是一个程序猿, 我不会爬树...\n");
#endif
    for(int i=0; i<NUMBER; ++i)
    {
        printf("hello, GCC!!!\n");
    }
    return 0;
}
```

在程序的第七行对`DEBUG`宏进行了判断，如果该宏被定义了，那么第八行就会进行日志输出，如果没有定义这个宏，第八行就相当于被注释掉了，因此最终无法看到日志输入出（**上述代码中并没有定义这个宏**）。

为了让测试更灵活，我们可以不在代码中定义这个宏，而是在测试的时候去把它定义出来，其中一种方式就是在`gcc/g++`命令中去指定，如下：

```shell
$ gcc test.c -DDEBUG -o app
```

在`gcc/g++`命令中通过参数 `-D`指定出要定义的宏的名字，这样就相当于在代码中定义了一个宏，其名字为`DEBUG`。

在`CMake`中我们也可以做类似的事情，对应的命令叫做`add_definitions`:

```cmake
add_definitions(-D宏名称)
```

针对于上面的源文件编写一个`CMakeLists.txt`，内容如下：

```cmake
cmake_minimum_required(VERSION 3.0)
project(TEST)

add_definitions(-DDEBUG)
add_executable(app ./test.c)
```

通过这种方式，上述代码中的第八行日志就能够被输出出来了。

### 3 预定义宏

一些`CMake`中常用的宏：

| 宏                         | 功能                                                         |
| -------------------------- | ------------------------------------------------------------ |
| PROJECT\_SOURCE\_DIR       | 使用cmake命令后紧跟的目录，一般是工程的根目录                |
| PROJECT\_BINARY\_DIR       | 执行cmake命令的目录                                          |
| CMAKE\_CURRENT\_SOURCE_DIR | 当前处理的CMakeLists.txt所在的路径                           |
| CMAKE\_CURRENT\_BINARY_DIR | target 编译目录                                              |
| EXECUTABLE\_OUTPUT\_PATH   | 重新定义目标二进制可执行文件的存放位置                       |
| LIBRARY\_OUTPUT\_PATH      | 重新定义目标链接库文件的存放位置                             |
| PROJECT_NAME               | 返回通过PROJECT指令定义的项目名称                            |
| CMAKE\_BINARY\_DIR         | 项目实际构建路径，假设在`build`目录进行的构建，那么得到的就是这个目录的路径 |



### 4 嵌套的CMake⭐

如果项目很大，或者项目中有很多的源码目录，在通过CMake管理项目的时候如果只使用一个`CMakeLists.txt`，那么这个文件相对会比较复杂，有一种化繁为简的方式就是给每个源码目录都添加一个`CMakeLists.txt`文件（头文件目录不需要），这样每个文件都不会太复杂，而且更灵活，更容易维护。

先来看一下下面的这个的目录结构：

```shell
$ tree
.
├── build
├── calc
│   ├── add.cpp
│   ├── CMakeLists.txt
│   ├── div.cpp
│   ├── mult.cpp
│   └── sub.cpp
├── CMakeLists.txt
├── include
│   ├── calc.h
│   └── sort.h
├── sort
│   ├── CMakeLists.txt
│   ├── insert.cpp
│   └── select.cpp
├── test1
│   ├── calc.cpp
│   └── CMakeLists.txt
└── test2
    ├── CMakeLists.txt
    └── sort.cpp

6 directories, 15 files
```

*   `include 目录`：头文件目录
*   `calc 目录`：目录中的四个源文件对应的加、减、乘、除算法
    *   对应的头文件是`include`中的`calc.h`
*   `sort 目录` ：目录中的两个源文件对应的是插入排序和选择排序算法
    *   对应的头文件是`include`中的`sort.h`
*   `test1 目录`：测试目录，对加、减、乘、除算法进行测试
*   `test2 目录`：测试目录，对排序算法进行测试

可以看到各个源文件目录所需要的`CMakeLists.txt`文件现在已经添加完毕了。接下来庖丁解牛，我们依次分析一下各个文件中需要添加的内容。

#### 4.1 准备工作

##### 4.1.1 节点关系

众所周知，Linux的目录是树状结构，所以`嵌套的 CMake 也是一个树状结构，最顶层的 CMakeLists.txt 是根节点，其次都是子节点。`因此，我们需要了解一些关于 `CMakeLists.txt` 文件变量作用域的一些信息：

*   根节点`CMakeLists.txt`中的变量全局有效
*   父节点`CMakeLists.txt`中的变量可以在子节点中使用
*   子节点`CMakeLists.txt`中的变量只能在当前节点中使用

##### 4.1.2 添加子目录⭐

接下来我们还需要知道在 CMake 中父子节点之间的关系是如何建立的，这里需要用到一个 CMake 命令：

```cmake
add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])
```

*   `source_dir`：指定了`CMakeLists.txt`源文件和代码文件的位置，其实就是指定子目录
*   `binary_dir`：指定了输出文件的路径，一般不需要指定，忽略即可。
*   `EXCLUDE_FROM_ALL`：在子路径下的目标默认不会被包含到父路径的`ALL`目标里，并且也会被排除在IDE工程文件之外。用户必须显式构建在子路径下的目标。

通过这种方式`CMakeLists.txt`文件之间的父子关系就被构建出来了。

#### 4.2 最终代码⭐⭐

在上面的目录中我们要做如下事情：

1.  通过 `test1 目录`中的测试文件进行计算器相关的测试
2.  通过 `test2 目录`中的测试文件进行排序相关的测试

现在相当于是要进行模块化测试，对于`calc`和`sort`目录中的源文件来说，可以将它们**先编译成库文件**（可以是静态库也可以是动态库）然后在提供给测试文件使用即可。库文件的本质其实还是代码，只不过是从文本格式变成了二进制格式。

##### 4.2.1 根目录

根目录中的 `CMakeLists.txt`文件内容如下：

```cmake
cmake_minimum_required(VERSION 3.0)
project(test)
# 定义变量
# 静态库生成的路径
set(LIB_PATH ${CMAKE_CURRENT_SOURCE_DIR}/lib)
# 测试程序生成的路径
set(EXEC_PATH ${CMAKE_CURRENT_SOURCE_DIR}/bin)
# 头文件目录
set(HEAD_PATH ${CMAKE_CURRENT_SOURCE_DIR}/include)
# 静态库的名字
set(CALC_LIB calc)
set(SORT_LIB sort)
# 可执行程序的名字
set(APP_NAME_1 test1)
set(APP_NAME_2 test2)
# 添加子目录
add_subdirectory(calc)
add_subdirectory(sort)
add_subdirectory(test1)
add_subdirectory(test2)
```

在根节点对应的文件中主要做了两件事情：`定义全局变量`和`添加子目录`。

*   定义的全局变量主要是给子节点使用，目的是为了提高子节点中的`CMakeLists.txt`文件的可读性和可维护性，避免冗余并降低出差的概率。
*   一共添加了四个子目录，每个子目录中都有一个`CMakeLists.txt`文件，这样它们的父子关系就被确定下来了。

##### 4.2.2 calc 目录

calc 目录中的 `CMakeLists.txt`文件内容如下：

```cmake
cmake_minimum_required(VERSION 3.0)
project(CALCLIB)
aux_source_directory(./ SRC)
include_directories(${HEAD_PATH})
set(LIBRARY_OUTPUT_PATH ${LIB_PATH})
add_library(${CALC_LIB} STATIC ${SRC})
```

*   第3行`aux_source_directory`：搜索当前目录（calc目录）下的所有源文件
*   第4行`include_directories`：包含头文件路径，`HEAD_PATH`是在根节点文件中定义的
*   第5行`set`：设置库的生成的路径，`LIB_PATH`是在根节点文件中定义的
*   第6行`add_library`：生成静态库，静态库名字`CALC_LIB`是在根节点文件中定义的

##### 4.2.3 sort 目录

sort 目录中的 `CMakeLists.txt`文件内容如下：

```cmake
cmake_minimum_required(VERSION 3.0)
project(SORTLIB)
aux_source_directory(./ SRC)
include_directories(${HEAD_PATH})
set(LIBRARY_OUTPUT_PATH ${LIB_PATH})
add_library(${SORT_LIB} SHARED ${SRC})
```

*   第6行`add_library`：生成动态库，动态库名字`SORT_LIB`是在根节点文件中定义的

这个文件中的内容和`calc`节点文件中的内容类似，只不过这次生成的是动态库。

在生成库文件的时候，这个库可以是静态库也可以是动态库，一般需要根据实际情况来确定。如果生成的库比较大，建议将其制作成动态库。

##### 4.2.4 test1 目录

test1 目录中的 `CMakeLists.txt`文件内容如下：

```cmake
cmake_minimum_required(VERSION 3.0)
project(CALCTEST)
aux_source_directory(./ SRC)
include_directories(${HEAD_PATH})
link_directories(${LIB_PATH})
link_libraries(${CALC_LIB})
set(EXECUTABLE_OUTPUT_PATH ${EXEC_PATH})
add_executable(${APP_NAME_1} ${SRC})
```

*   第4行`include_directories`：指定头文件路径，`HEAD_PATH`变量是在根节点文件中定义的
*   第6行`link_libraries`：指定可执行程序要链接的`静态库`，`CALC_LIB`变量是在根节点文件中定义的
*   第7行`set`：指定可执行程序生成的路径，`EXEC_PATH`变量是在根节点文件中定义的
*   第8行`add_executable`：生成可执行程序，`APP_NAME_1`变量是在根节点文件中定义的

此处的可执行程序链接的是静态库，最终静态库会被打包到可执行程序中，可执行程序启动之后，静态库也就随之被加载到内存中了。

##### 4.2.5 test2 目录

test2 目录中的 `CMakeLists.txt`文件内容如下：

```cmake
cmake_minimum_required(VERSION 3.0)
project(SORTTEST)
aux_source_directory(./ SRC)
include_directories(${HEAD_PATH})
set(EXECUTABLE_OUTPUT_PATH ${EXEC_PATH})
link_directories(${LIB_PATH})
add_executable(${APP_NAME_2} ${SRC})
target_link_libraries(${APP_NAME_2} ${SORT_LIB})
```

*   第四行`include_directories`：包含头文件路径，`HEAD_PATH`变量是在根节点文件中定义的
*   第五行`set`：指定可执行程序生成的路径，`EXEC_PATH`变量是在根节点文件中定义的
*   第六行`link_directories`：指定可执行程序要链接的动态库的路径，`LIB_PATH`变量是在根节点文件中定义的
*   第七行`add_executable`：生成可执行程序，`APP_NAME_2`变量是在根节点文件中定义的
*   第八行`target_link_libraries`：指定可执行程序要链接的动态库的名字

在生成可执行程序的时候，动态库不会被打包到可执行程序内部。当可执行程序启动之后动态库也不会被加载到内存，只有可执行程序调用了动态库中的函数的时候，动态库才会被加载到内存中，且多个进程可以共用内存中的同一个动态库，所以动态库又叫共享库。

##### 4.2.6 构建项目

一切准备就绪之后，开始构建项目，进入到根节点目录的`build 目录`中，执行`cmake 命令`，如下：

```shell
$ cmake ..
-- The C compiler identification is GNU 5.4.0
-- The CXX compiler identification is GNU 5.4.0
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done
-- Configuring done
-- Generating done
-- Build files have been written to: /home/robin/abc/cmake/calc/build
```

可以看到在`build`目录中生成了一些文件和目录，如下所示：

```shell
$ tree build -L 1     
build
├── calc                  # 目录
├── CMakeCache.txt        # 文件
├── CMakeFiles            # 目录
├── cmake_install.cmake   # 文件
├── Makefile              # 文件
├── sort                  # 目录
├── test1                 # 目录
└── test2                 # 目录
```

然后在`build 目录`下执行`make 命令`:

![](https://img.zimei.fun/202406231146019.png)

通过上图可以得到如下信息：

1.  在项目根目录的`lib`目录中生成了静态库`libcalc.a`
2.  在项目根目录的`lib`目录中生成了动态库`libsort.so`
3.  在项目根目录的`bin`目录中生成了可执行程序`test1`
4.  在项目根目录的`bin`目录中生成了可执行程序`test2`

最后再来看一下上面提到的这些文件是否真的被生成到对应的目录中了:

```shell
$ tree bin/ lib/
bin/
├── test1
└── test2
lib/
├── libcalc.a
└── libsort.so
```

由此可见，真实不虚，至此，项目构建完毕。

写在最后：

在项目中，如果将程序中的某个模块制作成了动态库或者静态库`并且在CMakeLists.txt 中指定了库的输出目录`，而后其它模块又需要加载这个生成的库文件，此时直接使用就可以了，`如果没有指定库的输出路径或者需要直接加载外部提供的库文件，此时就需要使用 link_directories 将库文件路径指定出来。`

### 5 流程控制

在 CMake 的 CMakeLists.txt 中也可以进行流程控制，也就是说可以像写 shell 脚本那样进行`条件判断`和`循环`。

#### 5.1 条件判断

关于条件判断其语法格式如下：

```cmake
if(<condition>)
  <commands>
elseif(<condition>) # 可选快, 可以重复
  <commands>
else()              # 可选快
  <commands>
endif()
```

在进行条件判断的时候，如果有多个条件，那么可以写多个`elseif`，最后一个条件可以使用`else`，但是**开始和结束是必须要成对出现的**，分别为：`if`和`endif`。

##### 5.1.1 基本表达式

```cmake
if(<expression>)
```

如果是基本表达式，`expression` 有以下三种情况：`常量`、`变量`、`字符串`。

*   如果是`1`, `ON`, `YES`, `TRUE`, `Y`, `非零值`，`非空字符串`时，条件判断返回`True`
*   如果是 `0`, `OFF`, `NO`, `FALSE`, `N`, `IGNORE`, `NOTFOUND`，`空字符串`时，条件判断返回`False`

##### 5.1.2 逻辑判断

*   **NOT**
    
    ```cmake
    if(NOT <condition>)
    ```
    
    其实这就是一个取反操作，如果条件`condition`为`True`将返回`False`，如果条件`condition`为`False`将返回`True`。
    
*   **AND**
    
    ```cmake
    if(<cond1> AND <cond2>)
    ```
    
    如果`cond1`和`cond2`同时为`True`，返回`True`否则返回`False`。
    
*   **OR**
    
    ```cmake
    if(<cond1> OR <cond2>)
    ```
    
    如果`cond1`和`cond2`两个条件中至少有一个为`True`，返回`True`，如果两个条件都为`False`则返回`False`。
    

##### 5.1.3 比较

*   **基于数值的比较**
    
    ```cmake
    if(<variable|string> LESS <variable|string>)
    if(<variable|string> GREATER <variable|string>)
    if(<variable|string> EQUAL <variable|string>)
    if(<variable|string> LESS_EQUAL <variable|string>)
    if(<variable|string> GREATER_EQUAL <variable|string>)
    ```
    
    *   `LESS`：如果左侧数值`小于`右侧，返回`True`
    *   `GREATER`：如果左侧数值`大于`右侧，返回`True`
    *   `EQUAL`：如果左侧数值`等于`右侧，返回`True`
    *   `LESS_EQUAL`：如果左侧数值`小于等于`右侧，返回`True`
    *   `GREATER_EQUAL`：如果左侧数值`大于等于`右侧，返回`True`
*   **基于字符串的比较**
    
    ```cmake
    if(<variable|string> STRLESS <variable|string>)
    if(<variable|string> STRGREATER <variable|string>)
    if(<variable|string> STREQUAL <variable|string>)
    if(<variable|string> STRLESS_EQUAL <variable|string>)
    if(<variable|string> STRGREATER_EQUAL <variable|string>)
    ```
    
    *   `STRLESS`：如果左侧字符串`小于`右侧，返回`True`
    *   `STRGREATER`：如果左侧字符串`大于`右侧，返回`True`
    *   `STREQUAL`：如果左侧字符串`等于`右侧，返回`True`
    *   `STRLESS_EQUAL`：如果左侧字符串`小于等于`右侧，返回`True`
    *   `STRGREATER_EQUAL`：如果左侧字符串`大于等于`右侧，返回`True`

##### 5.1.4 文件操作

1.  判断文件或者目录是否存在
    
    ```cmake
    if(EXISTS path-to-file-or-directory)
    ```
    
    如果文件或者目录存在返回`True`，否则返回`False`。
    
2.  判断是不是目录
    
    ```cmake
    if(IS_DIRECTORY path)
    ```
    
    *   此处目录的 path 必须是绝对路径
    *   如果目录存在返回`True`，目录不存在返回`False`。
3.  判断是不是软连接
    
    ```cmake
    if(IS_SYMLINK file-name)
    ```
    
    *   此处的 file-name 对应的路径必须是绝对路径
    *   如果软链接存在返回`True`，软链接不存在返回`False`。
    *   软链接相当于 Windows 里的快捷方式
4.  判断是不是绝对路径
    
    ```cmake
    if(IS_ABSOLUTE path)
    ```
    
    *   关于绝对路径:
        *   如果是`Linux`，该路径需要从根目录开始描述
        *   如果是`Windows`，该路径需要从盘符开始描述
    *   如果是绝对路径返回`True`，如果不是绝对路径返回`False`。

##### 5.1.5 其它

*   判断某个元素是否在列表中
    
    ```cmake
    if(<variable|string> IN_LIST <variable>)
    ```
    
    *   CMake 版本要求：大于等于3.3
    *   如果这个元素在列表中返回`True`，否则返回`False`。
*   比较两个路径是否相等
    
    ```cmake
    if(<variable|string> PATH_EQUAL <variable|string>)
    ```
    
    *   CMake 版本要求：大于等于3.24
    *   如果这个元素在列表中返回`True`，否则返回`False`。
    
    关于路径的比较其实就是另个字符串的比较，如果路径格式书写没有问题也可以通过下面这种方式进行比较：
    
    ```cmake
    if(<variable|string> STREQUAL <variable|string>)
    ```
    
    我们在书写某个路径的时候，可能由于误操作会多写几个分隔符，比如把`/a/b/c`写成`/a//b///c`，此时通过`STREQUAL`对这两个字符串进行比较肯定是不相等的，但是通过`PATH_EQUAL`去比较两个路径，得到的结果确实相等的，可以看下面的例子：
    
    ```cmake
    cmake_minimum_required(VERSION 3.26)
    project(test)
    
    if("/home//robin///Linux" PATH_EQUAL "/home/robin/Linux")
        message("路径相等")
    else()
        message("路径不相等")
    endif()
    
    message(STATUS "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@")
    
    if("/home//robin///Linux" STREQUAL "/home/robin/Linux")
        message("路径相等")
    else()
        message("路径不相等")
    endif()
    ```
    
    输出的日志信息如下:
    
    ```shell
    路径相等
    @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
    路径不相等
    ```
    
    通过得到的结果我们可以得到一个结论：在进行路径比较的时候，如果使用 PATH_EQUAL 可以自动剔除路径中多余的分割线然后再进行路径的对比，使用 STREQUAL 则只能进行字符串比较。
    
    [关于 if 的更多条件判断，请参考官方文档](https://cmake.org/cmake/help/latest/command/if.html "关于 if 的更多条件判断，请参考官方文档")

#### 5.2 循环

在 CMake 中循环有两种方式，分别是：`foreach`和`while`。

##### 5.2.1 foreach

使用 foreach 进行循环，语法格式如下：

```cmake
foreach(<loop_var> <items>)
    <commands>
endforeach()
```

通过`foreach`我们就可以对`items`中的数据进行遍历，然后通过`loop_var`将遍历到的当前的值取出，在取值的时候有以下几种用法：

###### 方法1

```cmake
foreach(<loop_var> RANGE <stop>)
```

*   `RANGE`：关键字，表示要遍历范围
*   `stop`：这是一个`正整数，表示范围的结束值`，在遍历的时候`从 0 开始，最大值为 stop`。
*   `loop_var`：存储每次循环取出的值

举例说明：

```cmake
cmake_minimum_required(VERSION 3.2)
project(test)

foreach(item RANGE 10)
    message(STATUS "当前遍历的值为: ${item}" )
endforeach()
```

输出的日志信息是这样的：

```shell
$ cmake ..
-- 当前遍历的值为: 0
-- 当前遍历的值为: 1
-- 当前遍历的值为: 2
-- 当前遍历的值为: 3
-- 当前遍历的值为: 4
-- 当前遍历的值为: 5
-- 当前遍历的值为: 6
-- 当前遍历的值为: 7
-- 当前遍历的值为: 8
-- 当前遍历的值为: 9
-- 当前遍历的值为: 10
-- Configuring done
-- Generating done
-- Build files have been written to: /home/robin/abc/a/build
```

再次强调：在对一个整数区间进行遍历的时候，得到的范围是这样的 【0，stop】，右侧是闭区间包含 stop 这个值。

###### 方法2

```cmake
foreach(<loop_var> RANGE <start> <stop> [<step>])
```

这是上面`方法1`的加强版，我们在遍历一个整数区间的时候，除了可以指定起始范围，还可以指定步长。

*   `RANGE`：关键字，表示要遍历范围
*   `start`：这是一个`正整数，表示范围的起始值，也就是说最小值为 start`
*   `stop`：这是一个`正整数，表示范围的结束值，也就是说最大值为 stop`
*   `step`：控制每次遍历的时候以怎样的步长增长，`默认为1，可以不设置`
*   `loop_var`：存储每次循环取出的值

举例说明：

```cmake
cmake_minimum_required(VERSION 3.2)
project(test)

foreach(item RANGE 10 30 2)
    message(STATUS "当前遍历的值为: ${item}" )
endforeach()
```

输出的结果如下:

```shell
$ cmake ..
-- 当前遍历的值为: 10
-- 当前遍历的值为: 12
-- 当前遍历的值为: 14
-- 当前遍历的值为: 16
-- 当前遍历的值为: 18
-- 当前遍历的值为: 20
-- 当前遍历的值为: 22
-- 当前遍历的值为: 24
-- 当前遍历的值为: 26
-- 当前遍历的值为: 28
-- 当前遍历的值为: 30
-- Configuring done
-- Generating done
-- Build files have been written to: /home/robin/abc/a/build
```

再次强调：在使用上面的方式对一个整数区间进行遍历的时候，得到的范围是这样的 【start，stop】，左右两侧都是闭区间，包含 start 和 stop 这两个值，步长 step 默认为1，可以不设置。

###### 方法3

```cmake
foreach(<loop_var> IN [LISTS [<lists>]] [ITEMS [<items>]])
```

这是`foreach`的另一个变体，通过这种方式我们可以对更加复杂的数据进行遍历，前两种方式只适用于对某个正整数范围内的遍历。

*   `IN`：关键字，表示在 xxx 里边
    
*   `LISTS`：关键字，对应的是列表`list`，通过`set、list`可以获得
    
*   `ITEMS`：关键字，对应的也是列表
    
*   `loop_var`：存储每次循环取出的值
    

```cmake
cmake_minimum_required(VERSION 3.2)
project(test)

set(WORD a b c d)
set(NAME ace sabo luffy)

foreach(item IN LISTS WORD NAME)
    message(STATUS "当前遍历的值为: ${item}" )
endforeach()
```

在上面的例子中，创建了两个 `list` 列表，在遍历的时候对它们两个都进行了遍历（`可以根据实际需求选择同时遍历多个或者只遍历一个`）。输出的日志信息如下：

```shell
$ cd build/
$ cmake ..
-- 当前遍历的值为: a
-- 当前遍历的值为: b
-- 当前遍历的值为: c
-- 当前遍历的值为: d
-- 当前遍历的值为: ace
-- 当前遍历的值为: sabo
-- 当前遍历的值为: luffy
-- Configuring done
-- Generating done
-- Build files have been written to: /home/robin/abc/a/build
```

一共输出了7个字符串，说明遍历是没有问题的。接下来看另外一种方式：

```cmake
cmake_minimum_required(VERSION 3.2)
project(test)

set(WORD a b c "d e f")
set(NAME ace sabo luffy)
foreach(item IN ITEMS ${WORD} ${NAME})
    message(STATUS "当前遍历的值为: ${item}" )
endforeach()
```

在上面的例子中，遍历过程中将关键字`LISTS`改成了`ITEMS`，后边跟的还是一个或者多个列表，只不过此时需要通过`${}`将列表中的值取出。其输出的信息和上一个例子是一样的：

```shell
$ cd build/
$ cmake ..
-- 当前遍历的值为: a
-- 当前遍历的值为: b
-- 当前遍历的值为: c
-- 当前遍历的值为: d e f
-- 当前遍历的值为: ace
-- 当前遍历的值为: sabo
-- 当前遍历的值为: luffy
-- Configuring done
-- Generating done
-- Build files have been written to: /home/robin/abc/a/build
```

小细节：在通过 set 组织列表的时候，如果某个字符串中有空格，可以通过双引号将其包裹起来，具体的操作方法可以参考上面的例子。

###### 方法4

**注意事项：这种循环方式要求CMake的版本大于等于 3.17。** 

```cmake
foreach(<loop_var>... IN ZIP_LISTS <lists>)
```

通过这种方式，遍历的还是一个或多个列表，可以理解为是`方式3`的加强版。因为通过上面的方式遍历多个列表，但是又想把指定列表中的元素取出来使用是做不到的，在这个加强版中就可以轻松实现。

*   `loop_var`：存储每次循环取出的值，可以根据要遍历的列表的数量指定多个变量，用于存储对应的列表当前取出的那个值。
    *   `如果指定了多个变量名，它们的数量应该和列表的数量相等`
    *   `如果只给出了一个 loop_var，那么它将一系列的 loop_var_N 变量来存储对应列表中的当前项，也就是说 loop_var_0 对应第一个列表，loop_var_1 对应第二个列表，以此类推......`
    *   `如果遍历的多个列表中一个列表较短，当它遍历完成之后将不会再参与后续的遍历（因为其它列表还没有遍历完）。`
*   `IN`：关键字，表示在 xxx 里边
*   `ZIP_LISTS`：关键字，对应的是列表`list`，通过`set 、list`可以获得

```cmake
cmake_minimum_required(VERSION 3.17)
project(test)

list(APPEND WORD hello world "hello world")
list(APPEND NAME ace sabo luffy zoro sanji)

foreach(item1 item2 IN ZIP_LISTS WORD NAME)
    message(STATUS "当前遍历的值为: item1 = ${item1}, item2=${item2}" )
endforeach()

message("=============================")

foreach(item  IN ZIP_LISTS WORD NAME)
    message(STATUS "当前遍历的值为: item1 = ${item_0}, item2=${item_1}" )
endforeach()
```

在这个例子中关于列表数据的添加是通过`list`来实现的。在遍历列表的时候一共使用了两种方式，一种提供了多个变量来存储当前列表中的值，另一种只有一个变量，但是实际取值的时候需要通过`变量名_0、变量名_1、变量名_N` 的方式来操作，注意事项：第一个列表对应的编号是0，第一个列表对应的编号是0，第一个列表对应的编号是0。

上面的例子输出的结果如下：

```shell
$ cd build/
$ cmake ..
-- 当前遍历的值为: item1 = hello, item2=ace
-- 当前遍历的值为: item1 = world, item2=sabo
-- 当前遍历的值为: item1 = hello world, item2=luffy
-- 当前遍历的值为: item1 = , item2=zoro
-- 当前遍历的值为: item1 = , item2=sanji
=============================
-- 当前遍历的值为: item1 = hello, item2=ace
-- 当前遍历的值为: item1 = world, item2=sabo
-- 当前遍历的值为: item1 = hello world, item2=luffy
-- 当前遍历的值为: item1 = , item2=zoro
-- 当前遍历的值为: item1 = , item2=sanji
-- Configuring done (0.0s)
-- Generating done (0.0s)
-- Build files have been written to: /home/robin/abc/a/build
```

##### 5.2.2 while

除了使用`foreach`也可以使用 `while` 进行循环，关于循环结束对应的条件判断的书写格式和`if/elseif` 是一样的。`while`的语法格式如下：

```cmake
while(<condition>)
    <commands>
endwhile()
```

`while`循环比较简单，只需要指定出循环结束的条件即可：

```cmake
cmake_minimum_required(VERSION 3.5)
project(test)
# 创建一个列表 NAME
set(NAME luffy sanji zoro nami robin)
# 得到列表长度
list(LENGTH NAME LEN)
# 循环
while(${LEN} GREATER  0)
    message(STATUS "names = ${NAME}")
    # 弹出列表头部元素
    list(POP_FRONT NAME)
    # 更新列表长度
    list(LENGTH NAME LEN)
endwhile()
```

输出的结果如下:

```shell
$ cd build/
$ cmake ..
-- names = luffy;sanji;zoro;nami;robin
-- names = sanji;zoro;nami;robin
-- names = zoro;nami;robin
-- names = nami;robin
-- names = robin
-- Configuring done (0.0s)
-- Generating done (0.0s)
-- Build files have been written to: /home/robin/abc/a/build
```

可以看到当列表中的元素全部被弹出之后，列表的长度变成了0，此时`while`循环也就退出了。

## ~~四 Autoconf~~

[Autoconf 教程 Part-1 ](https://mp.weixin.qq.com/s/nMKmuWkC8w6q9fEpAjCLDQ)

## 五 参考文献

> [GCC | 爱编程的大丙 (subingwen.cn)](https://subingwen.cn/linux/gcc/)
>
> [Makefile | 爱编程的大丙 (subingwen.cn)](https://subingwen.cn/linux/makefile/?highlight=make)
>
> [cmake-commands(7) — CMake 3.30.0-rc3 Documentation](https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html)
>
> [CMake 保姆级教程（上） | 爱编程的大丙 (subingwen.cn)](https://subingwen.cn/cmake/CMake-primer/)
>
> [Autoconf Tutorial Part-1 - Carpe diem (Felix's blog) (idryman.org)](https://www.idryman.org/blog/2016/03/10/autoconf-tutorial-1/?_refluxos=a10)
>
> [Autoconf编译配置-CSDN博客](https://blog.csdn.net/qq_35629060/article/details/120037039)
>
> **强推**！[B站-爱编程的大丙](https://space.bilibili.com/147020887)